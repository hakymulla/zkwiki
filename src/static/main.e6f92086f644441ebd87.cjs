"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var binFileUtils=require("@iden3/binfileutils"),ffjavascript=require("ffjavascript"),Blake2b=require("blake2b-wasm"),readline=require("readline"),crypto=require("crypto"),fastFile=require("fastfile"),circom_runtime=require("circom_runtime"),r1csfile=require("r1csfile"),ejs=require("ejs"),jsSha3=require("js-sha3");function _interopDefaultLegacy(e){return e&&"object"===typeof e&&"default"in e?e:{default:e}}function _interopNamespace(e){if(e&&e.__esModule)return e;var a=Object.create(null);return e&&Object.keys(e).forEach((function(t){if("default"!==t){var i=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(a,t,i.get?i:{enumerable:!0,get:function(){return e[t]}})}})),a.default=e,Object.freeze(a)}var binFileUtils__namespace=_interopNamespace(binFileUtils),Blake2b__default=_interopDefaultLegacy(Blake2b),readline__default=_interopDefaultLegacy(readline),crypto__default=_interopDefaultLegacy(crypto),fastFile__namespace=_interopNamespace(fastFile),ejs__default=_interopDefaultLegacy(ejs),jsSha3__default=_interopDefaultLegacy(jsSha3);ffjavascript.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),ffjavascript.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");const bls12381q=ffjavascript.Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),bn128q=ffjavascript.Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function getCurveFromQ(e){let a;if(ffjavascript.Scalar.eq(e,bn128q))a=await ffjavascript.buildBn128();else{if(!ffjavascript.Scalar.eq(e,bls12381q))throw new Error(`Curve not supported: ${ffjavascript.Scalar.toString(e)}`);a=await ffjavascript.buildBls12381()}return a}async function getCurveFromName(e){let a;const t=e.toUpperCase().match(/[A-Za-z0-9]+/g).join("");if(["BN128","BN254","ALTBN128"].indexOf(t)>=0)a=await ffjavascript.buildBn128();else{if(!(["BLS12381"].indexOf(t)>=0))throw new Error(`Curve not supported: ${e}`);a=await ffjavascript.buildBls12381()}return a}const _revTable=[];for(let e=0;e<256;e++)_revTable[e]=_revSlow(e,8);function _revSlow(e,a){let t=0,i=e;for(let n=0;n<a;n++)t<<=1,t|=1&i,i>>=1;return t}function log2(e){return(0!==(4294901760&e)?(e&=4294901760,16):0)|(0!==(4278255360&e)?(e&=4278255360,8):0)|(0!==(4042322160&e)?(e&=4042322160,4):0)|(0!==(3435973836&e)?(e&=3435973836,2):0)|0!==(2863311530&e)}function formatHash(e,a){const t=new DataView(e.buffer,e.byteOffset,e.byteLength);let i="";for(let n=0;n<4;n++){n>0&&(i+="\n"),i+="\t\t";for(let e=0;e<4;e++)e>0&&(i+=" "),i+=t.getUint32(16*n+4*e).toString(16).padStart(8,"0")}return a&&(i=a+"\n"+i),i}function hashIsEqual(e,a){if(e.byteLength!=a.byteLength)return!1;for(var t=new Int8Array(e),i=new Int8Array(a),n=0;n!=e.byteLength;n++)if(t[n]!=i[n])return!1;return!0}function cloneHasher(e){const a=e.getPartialHash(),t=Blake2b__default.default(64);return t.setPartialHash(a),t}async function sameRatio$2(e,a,t,i,n){if(e.G1.isZero(a))return!1;if(e.G1.isZero(t))return!1;if(e.G2.isZero(i))return!1;if(e.G2.isZero(n))return!1;return await e.pairingEq(a,n,e.G1.neg(t),i)}function askEntropy(){if(process.browser)return window.prompt("Enter a random text. (Entropy): ","");{const e=readline__default.default.createInterface({input:process.stdin,output:process.stdout});return new Promise((a=>{e.question("Enter a random text. (Entropy): ",(e=>a(e)))}))}}async function getRandomRng(e){for(;!e;)e=await askEntropy();const a=Blake2b__default.default(64);a.update(crypto__default.default.randomBytes(64));const t=new TextEncoder;a.update(t.encode(e));const i=Buffer.from(a.digest()),n=[];for(let r=0;r<8;r++)n[r]=i.readUInt32BE(4*r);return new ffjavascript.ChaCha(n)}function rngFromBeaconParams(e,a){let t,i;a<32?(t=1<<a>>>0,i=1):(t=4294967296,i=1<<a-32>>>0);let n=e;for(let s=0;s<i;s++)for(let e=0;e<t;e++)n=crypto__default.default.createHash("sha256").update(n).digest();const r=new DataView(n.buffer,n.byteOffset,n.byteLength),o=[];for(let s=0;s<8;s++)o[s]=r.getUint32(4*s,!1);return new ffjavascript.ChaCha(o)}function hex2ByteArray(e){return e instanceof Uint8Array?e:("0x"==e.slice(0,2)&&(e=e.slice(2)),new Uint8Array(e.match(/[\da-f]{2}/gi).map((function(e){return parseInt(e,16)}))))}function byteArray2hex(e){return Array.prototype.map.call(e,(function(e){return("0"+(255&e).toString(16)).slice(-2)})).join("")}async function writeHeader(e,a){await binFileUtils__namespace.startWriteSection(e,1),await e.writeULE32(1),await binFileUtils__namespace.endWriteSection(e);const t=await getCurveFromQ(a.q);await binFileUtils__namespace.startWriteSection(e,2);const i=t.q,n=8*(Math.floor((ffjavascript.Scalar.bitLength(i)-1)/64)+1),r=t.r,o=8*(Math.floor((ffjavascript.Scalar.bitLength(r)-1)/64)+1);await e.writeULE32(n),await binFileUtils__namespace.writeBigInt(e,i,n),await e.writeULE32(o),await binFileUtils__namespace.writeBigInt(e,r,o),await e.writeULE32(a.nVars),await e.writeULE32(a.nPublic),await e.writeULE32(a.domainSize),await writeG1(e,t,a.vk_alpha_1),await writeG1(e,t,a.vk_beta_1),await writeG2(e,t,a.vk_beta_2),await writeG2(e,t,a.vk_gamma_2),await writeG1(e,t,a.vk_delta_1),await writeG2(e,t,a.vk_delta_2),await binFileUtils__namespace.endWriteSection(e)}async function writeG1(e,a,t){const i=new Uint8Array(2*a.G1.F.n8);a.G1.toRprLEM(i,0,t),await e.write(i)}async function writeG2(e,a,t){const i=new Uint8Array(2*a.G2.F.n8);a.G2.toRprLEM(i,0,t),await e.write(i)}async function readG1(e,a,t){const i=await e.read(2*a.G1.F.n8),n=a.G1.fromRprLEM(i,0);return t?a.G1.toObject(n):n}async function readG2(e,a,t){const i=await e.read(2*a.G2.F.n8),n=a.G2.fromRprLEM(i,0);return t?a.G2.toObject(n):n}async function readHeader$1(e,a,t){await binFileUtils__namespace.startReadUniqueSection(e,a,1);const i=await e.readULE32();if(await binFileUtils__namespace.endReadSection(e),1==i)return await readHeaderGroth16(e,a,t);if(2==i)return await readHeaderPlonk(e,a);throw new Error("Protocol not supported: ")}async function readHeaderGroth16(e,a,t){const i={protocol:"groth16"};await binFileUtils__namespace.startReadUniqueSection(e,a,2);const n=await e.readULE32();i.n8q=n,i.q=await binFileUtils__namespace.readBigInt(e,n);const r=await e.readULE32();i.n8r=r,i.r=await binFileUtils__namespace.readBigInt(e,r);let o=await getCurveFromQ(i.q);return i.nVars=await e.readULE32(),i.nPublic=await e.readULE32(),i.domainSize=await e.readULE32(),i.power=log2(i.domainSize),i.vk_alpha_1=await readG1(e,o,t),i.vk_beta_1=await readG1(e,o,t),i.vk_beta_2=await readG2(e,o,t),i.vk_gamma_2=await readG2(e,o,t),i.vk_delta_1=await readG1(e,o,t),i.vk_delta_2=await readG2(e,o,t),await binFileUtils__namespace.endReadSection(e),i}async function readHeaderPlonk(e,a,t,i){const n={protocol:"plonk"};await binFileUtils__namespace.startReadUniqueSection(e,a,2);const r=await e.readULE32();n.n8q=r,n.q=await binFileUtils__namespace.readBigInt(e,r);const o=await e.readULE32();n.n8r=o,n.r=await binFileUtils__namespace.readBigInt(e,o);let s=await getCurveFromQ(n.q);return n.nVars=await e.readULE32(),n.nPublic=await e.readULE32(),n.domainSize=await e.readULE32(),n.power=log2(n.domainSize),n.nAdditions=await e.readULE32(),n.nConstrains=await e.readULE32(),n.k1=await e.read(o),n.k2=await e.read(o),n.Qm=await readG1(e,s,i),n.Ql=await readG1(e,s,i),n.Qr=await readG1(e,s,i),n.Qo=await readG1(e,s,i),n.Qc=await readG1(e,s,i),n.S1=await readG1(e,s,i),n.S2=await readG1(e,s,i),n.S3=await readG1(e,s,i),n.X_2=await readG2(e,s,i),await binFileUtils__namespace.endReadSection(e),n}async function readZKey(e,a){const{fd:t,sections:i}=await binFileUtils__namespace.readBinFile(e,"zkey",1),n=await readHeader$1(t,i,"groth16"),r=new ffjavascript.F1Field(n.r),o=ffjavascript.Scalar.mod(ffjavascript.Scalar.shl(1,8*n.n8r),n.r),s=r.inv(o),l=r.mul(s,s);let c=await getCurveFromQ(n.q);await binFileUtils__namespace.startReadUniqueSection(t,i,3),n.IC=[];for(let d=0;d<=n.nPublic;d++){const e=await readG1(t,c,a);n.IC.push(e)}await binFileUtils__namespace.endReadSection(t),await binFileUtils__namespace.startReadUniqueSection(t,i,4);const u=await t.readULE32();n.ccoefs=[];for(let d=0;d<u;d++){const e=await t.readULE32(),a=await t.readULE32(),i=await t.readULE32(),r=await f();n.ccoefs.push({matrix:e,constraint:a,signal:i,value:r})}await binFileUtils__namespace.endReadSection(t),await binFileUtils__namespace.startReadUniqueSection(t,i,5),n.A=[];for(let d=0;d<n.nVars;d++){const e=await readG1(t,c,a);n.A[d]=e}await binFileUtils__namespace.endReadSection(t),await binFileUtils__namespace.startReadUniqueSection(t,i,6),n.B1=[];for(let d=0;d<n.nVars;d++){const e=await readG1(t,c,a);n.B1[d]=e}await binFileUtils__namespace.endReadSection(t),await binFileUtils__namespace.startReadUniqueSection(t,i,7),n.B2=[];for(let d=0;d<n.nVars;d++){const e=await readG2(t,c,a);n.B2[d]=e}await binFileUtils__namespace.endReadSection(t),await binFileUtils__namespace.startReadUniqueSection(t,i,8),n.C=[];for(let d=n.nPublic+1;d<n.nVars;d++){const e=await readG1(t,c,a);n.C[d]=e}await binFileUtils__namespace.endReadSection(t),await binFileUtils__namespace.startReadUniqueSection(t,i,9),n.hExps=[];for(let d=0;d<n.domainSize;d++){const e=await readG1(t,c,a);n.hExps.push(e)}return await binFileUtils__namespace.endReadSection(t),await t.close(),n;async function f(){const e=await binFileUtils__namespace.readBigInt(t,n.n8r);return r.mul(e,l)}}async function readContribution$1(e,a,t){const i={delta:{}};i.deltaAfter=await readG1(e,a,t),i.delta.g1_s=await readG1(e,a,t),i.delta.g1_sx=await readG1(e,a,t),i.delta.g2_spx=await readG2(e,a,t),i.transcript=await e.read(64),i.type=await e.readULE32();const n=await e.readULE32(),r=e.pos;let o=0;for(;e.pos-r<n;){const a=await e.read(1);if(a[0]<=o)throw new Error("Parameters in the contribution must be sorted");if(o=a[0],1==a[0]){const a=await e.read(1),t=await e.read(a[0]);i.name=(new TextDecoder).decode(t)}else if(2==a[0]){const a=await e.read(1);i.numIterationsExp=a[0]}else{if(3!=a[0])throw new Error("Parameter not recognized");{const a=await e.read(1);i.beaconHash=await e.read(a[0])}}}if(e.pos!=r+n)throw new Error("Parametes do not match");return i}async function readMPCParams(e,a,t){await binFileUtils__namespace.startReadUniqueSection(e,t,10);const i={contributions:[]};i.csHash=await e.read(64);const n=await e.readULE32();for(let r=0;r<n;r++){const t=await readContribution$1(e,a);i.contributions.push(t)}return await binFileUtils__namespace.endReadSection(e),i}async function writeContribution$1(e,a,t){await writeG1(e,a,t.deltaAfter),await writeG1(e,a,t.delta.g1_s),await writeG1(e,a,t.delta.g1_sx),await writeG2(e,a,t.delta.g2_spx),await e.write(t.transcript),await e.writeULE32(t.type||0);const i=[];if(t.name){i.push(1);const e=new TextEncoder("utf-8").encode(t.name.substring(0,64));i.push(e.byteLength);for(let a=0;a<e.byteLength;a++)i.push(e[a])}if(1==t.type){i.push(2),i.push(t.numIterationsExp),i.push(3),i.push(t.beaconHash.byteLength);for(let e=0;e<t.beaconHash.byteLength;e++)i.push(t.beaconHash[e])}if(i.length>0){const a=new Uint8Array(i);await e.writeULE32(a.byteLength),await e.write(a)}else await e.writeULE32(0)}async function writeMPCParams(e,a,t){await binFileUtils__namespace.startWriteSection(e,10),await e.write(t.csHash),await e.writeULE32(t.contributions.length);for(let i=0;i<t.contributions.length;i++)await writeContribution$1(e,a,t.contributions[i]);await binFileUtils__namespace.endWriteSection(e)}function hashG1(e,a,t){const i=new Uint8Array(2*a.G1.F.n8);a.G1.toRprUncompressed(i,0,t),e.update(i)}function hashG2(e,a,t){const i=new Uint8Array(2*a.G2.F.n8);a.G2.toRprUncompressed(i,0,t),e.update(i)}function hashPubKey(e,a,t){hashG1(e,a,t.deltaAfter),hashG1(e,a,t.delta.g1_s),hashG1(e,a,t.delta.g1_sx),hashG2(e,a,t.delta.g2_spx),e.update(t.transcript)}async function write(e,a,t){await binFileUtils__namespace.startWriteSection(e,1);const i=8*(Math.floor((ffjavascript.Scalar.bitLength(t)-1)/64)+1);await e.writeULE32(i),await binFileUtils__namespace.writeBigInt(e,t,i),await e.writeULE32(a.length),await binFileUtils__namespace.endWriteSection(e),await binFileUtils__namespace.startWriteSection(e,2);for(let n=0;n<a.length;n++)await binFileUtils__namespace.writeBigInt(e,a[n],i);await binFileUtils__namespace.endWriteSection(e,2)}async function writeBin(e,a,t){await binFileUtils__namespace.startWriteSection(e,1);const i=8*(Math.floor((ffjavascript.Scalar.bitLength(t)-1)/64)+1);if(await e.writeULE32(i),await binFileUtils__namespace.writeBigInt(e,t,i),a.byteLength%i!=0)throw new Error("Invalid witness length");await e.writeULE32(a.byteLength/i),await binFileUtils__namespace.endWriteSection(e),await binFileUtils__namespace.startWriteSection(e,2),await e.write(a),await binFileUtils__namespace.endWriteSection(e)}async function readHeader(e,a){await binFileUtils__namespace.startReadUniqueSection(e,a,1);const t=await e.readULE32(),i=await binFileUtils__namespace.readBigInt(e,t),n=await e.readULE32();return await binFileUtils__namespace.endReadSection(e),{n8:t,q:i,nWitness:n}}async function read(e){const{fd:a,sections:t}=await binFileUtils__namespace.readBinFile(e,"wtns",2),{n8:i,nWitness:n}=await readHeader(a,t);await binFileUtils__namespace.startReadUniqueSection(a,t,2);const r=[];for(let o=0;o<n;o++){const e=await binFileUtils__namespace.readBigInt(a,i);r.push(e)}return await binFileUtils__namespace.endReadSection(a),await a.close(),r}const{stringifyBigInts:stringifyBigInts$3}=ffjavascript.utils;async function groth16Prove(e,a,t){const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(a,"wtns",2,1<<25,1<<23),r=await readHeader(i,n),{fd:o,sections:s}=await binFileUtils__namespace.readBinFile(e,"zkey",2,1<<25,1<<23),l=await readHeader$1(o,s);if("groth16"!=l.protocol)throw new Error("zkey file is not groth16");if(!ffjavascript.Scalar.eq(l.r,r.q))throw new Error("Curve of the witness does not match the curve of the proving key");if(r.nWitness!=l.nVars)throw new Error(`Invalid witness length. Circuit: ${l.nVars}, witness: ${r.nWitness}`);const c=await getCurveFromQ(l.q),u=c.Fr,f=c.G1,d=c.G2,w=log2(l.domainSize);t&&t.debug("Reading Wtns");const p=await binFileUtils__namespace.readSection(i,n,2);t&&t.debug("Reading Coeffs");const m=await binFileUtils__namespace.readSection(o,s,4);t&&t.debug("Building ABC");const[b,g,h]=await buildABC1(c,l,p,m,t),_=w==u.s?c.Fr.shift:c.Fr.w[w+1],y=await u.ifft(b,"","",t,"IFFT_A"),F=await u.batchApplyKey(y,u.e(1),_),v=await u.fft(F,"","",t,"FFT_A"),G=await u.ifft(g,"","",t,"IFFT_B"),U=await u.batchApplyKey(G,u.e(1),_),S=await u.fft(U,"","",t,"FFT_B"),B=await u.ifft(h,"","",t,"IFFT_C"),E=await u.batchApplyKey(B,u.e(1),_),x=await u.fft(E,"","",t,"FFT_C");t&&t.debug("Join ABC");const A=await joinABC(c,l,v,S,x,t);let k={};t&&t.debug("Reading A Points");const C=await binFileUtils__namespace.readSection(o,s,5);k.pi_a=await c.G1.multiExpAffine(C,p,t,"multiexp A"),t&&t.debug("Reading B1 Points");const L=await binFileUtils__namespace.readSection(o,s,6);let R=await c.G1.multiExpAffine(L,p,t,"multiexp B1");t&&t.debug("Reading B2 Points");const z=await binFileUtils__namespace.readSection(o,s,7);k.pi_b=await c.G2.multiExpAffine(z,p,t,"multiexp B2"),t&&t.debug("Reading C Points");const T=await binFileUtils__namespace.readSection(o,s,8);k.pi_c=await c.G1.multiExpAffine(T,p.slice((l.nPublic+1)*c.Fr.n8),t,"multiexp C"),t&&t.debug("Reading H Points");const P=await binFileUtils__namespace.readSection(o,s,9),$=await c.G1.multiExpAffine(P,A,t,"multiexp H"),j=c.Fr.random(),I=c.Fr.random();k.pi_a=f.add(k.pi_a,l.vk_alpha_1),k.pi_a=f.add(k.pi_a,f.timesFr(l.vk_delta_1,j)),k.pi_b=d.add(k.pi_b,l.vk_beta_2),k.pi_b=d.add(k.pi_b,d.timesFr(l.vk_delta_2,I)),R=f.add(R,l.vk_beta_1),R=f.add(R,f.timesFr(l.vk_delta_1,I)),k.pi_c=f.add(k.pi_c,$),k.pi_c=f.add(k.pi_c,f.timesFr(k.pi_a,I)),k.pi_c=f.add(k.pi_c,f.timesFr(R,j)),k.pi_c=f.add(k.pi_c,f.timesFr(l.vk_delta_1,u.neg(u.mul(j,I))));let H=[];for(let O=1;O<=l.nPublic;O++){const e=p.slice(O*u.n8,O*u.n8+u.n8);H.push(ffjavascript.Scalar.fromRprLE(e))}return k.pi_a=f.toObject(f.toAffine(k.pi_a)),k.pi_b=d.toObject(d.toAffine(k.pi_b)),k.pi_c=f.toObject(f.toAffine(k.pi_c)),k.protocol="groth16",k.curve=c.name,await o.close(),await i.close(),k=stringifyBigInts$3(k),H=stringifyBigInts$3(H),{proof:k,publicSignals:H}}async function buildABC1(e,a,t,i,n){const r=e.Fr.n8,o=12+a.n8r,s=(i.byteLength-4)/o,l=new ffjavascript.BigBuffer(a.domainSize*r),c=new ffjavascript.BigBuffer(a.domainSize*r),u=new ffjavascript.BigBuffer(a.domainSize*r),f=[l,c];for(let d=0;d<s;d++){n&&d%1e6==0&&n.debug(`QAP AB: ${d}/${s}`);const a=i.slice(4+d*o,4+d*o+o),l=new DataView(a.buffer),c=l.getUint32(0,!0),u=l.getUint32(4,!0),w=l.getUint32(8,!0),p=a.slice(12,12+r);f[c].set(e.Fr.add(f[c].slice(u*r,u*r+r),e.Fr.mul(p,t.slice(w*r,w*r+r))),u*r)}for(let d=0;d<a.domainSize;d++)n&&d%1e6==0&&n.debug(`QAP C: ${d}/${a.domainSize}`),u.set(e.Fr.mul(l.slice(d*r,d*r+r),c.slice(d*r,d*r+r)),d*r);return[l,c,u]}async function joinABC(e,a,t,i,n,r){const o=1<<22,s=e.Fr.n8,l=Math.floor(t.byteLength/e.Fr.n8),c=[];for(let w=0;w<l;w+=o){r&&r.debug(`JoinABC: ${w}/${l}`);const a=Math.min(l-w,o),u=[],f=t.slice(w*s,(w+a)*s),d=i.slice(w*s,(w+a)*s),p=n.slice(w*s,(w+a)*s);u.push({cmd:"ALLOCSET",var:0,buff:f}),u.push({cmd:"ALLOCSET",var:1,buff:d}),u.push({cmd:"ALLOCSET",var:2,buff:p}),u.push({cmd:"ALLOC",var:3,len:a*s}),u.push({cmd:"CALL",fnName:"qap_joinABC",params:[{var:0},{var:1},{var:2},{val:a},{var:3}]}),u.push({cmd:"CALL",fnName:"frm_batchFromMontgomery",params:[{var:3},{val:a},{var:3}]}),u.push({cmd:"GET",out:0,var:3,len:a*s}),c.push(e.tm.queueAction(u))}const u=await Promise.all(c);let f;f=t instanceof ffjavascript.BigBuffer?new ffjavascript.BigBuffer(t.byteLength):new Uint8Array(t.byteLength);let d=0;for(let w=0;w<u.length;w++)f.set(u[w][0],d),d+=u[w][0].byteLength;return f}async function wtnsCalculate(e,a,t,i){const n=await fastFile__namespace.readExisting(a),r=await n.read(n.totalSize);await n.close();const o=await circom_runtime.WitnessCalculatorBuilder(r);if(1==o.circom_version()){const a=await o.calculateBinWitness(e),i=await binFileUtils__namespace.createBinFile(t,"wtns",2,2);await writeBin(i,a,o.prime),await i.close()}else{const a=await fastFile__namespace.createOverride(t),i=await o.calculateWTNSBin(e);await a.write(i),await a.close()}}async function groth16FullProve(e,a,t,i){const n={type:"mem"};return await wtnsCalculate(e,a,n),await groth16Prove(t,n,i)}const{unstringifyBigInts:unstringifyBigInts$1}=ffjavascript.utils;async function groth16Verify(e,a,t,i){e=unstringifyBigInts$1(e),t=unstringifyBigInts$1(t),a=unstringifyBigInts$1(a);const n=await getCurveFromName(e.curve),r=n.G1.fromObject(e.IC[0]),o=new Uint8Array(2*n.G1.F.n8*a.length),s=new Uint8Array(n.Fr.n8*a.length);for(let b=0;b<a.length;b++){const t=n.G1.fromObject(e.IC[b+1]);o.set(t,b*n.G1.F.n8*2),ffjavascript.Scalar.toRprLE(s,n.Fr.n8*b,a[b],n.Fr.n8)}let l=await n.G1.multiExpAffine(o,s);l=n.G1.add(l,r);const c=n.G1.fromObject(t.pi_a),u=n.G2.fromObject(t.pi_b),f=n.G1.fromObject(t.pi_c),d=n.G2.fromObject(e.vk_gamma_2),w=n.G2.fromObject(e.vk_delta_2),p=n.G1.fromObject(e.vk_alpha_1),m=n.G2.fromObject(e.vk_beta_2);return await n.pairingEq(n.G1.neg(c),u,l,d,f,w,p,m)?(i&&i.info("OK!"),!0):(i&&i.error("Invalid proof"),!1)}function p256$1(e){let a=e.toString(16);for(;a.length<64;)a="0"+a;return a=`"0x${a}"`,a}async function groth16ExportSolidityCallData(e,a){let t,i="";for(let n=0;n<a.length;n++)""!=i&&(i+=","),i+=p256$1(a[n]);return t=`[${p256$1(e.pi_a[0])}, ${p256$1(e.pi_a[1])}],[[${p256$1(e.pi_b[0][1])}, ${p256$1(e.pi_b[0][0])}],[${p256$1(e.pi_b[1][1])}, ${p256$1(e.pi_b[1][0])}]],[${p256$1(e.pi_c[0])}, ${p256$1(e.pi_c[1])}],[${i}]`,t}var groth16=Object.freeze({__proto__:null,fullProve:groth16FullProve,prove:groth16Prove,verify:groth16Verify,exportSolidityCallData:groth16ExportSolidityCallData});function hashToG2(e,a){const t=new DataView(a.buffer,a.byteOffset,a.byteLength),i=[];for(let r=0;r<8;r++)i[r]=t.getUint32(4*r);const n=new ffjavascript.ChaCha(i);return e.G2.fromRng(n)}function getG2sp(e,a,t,i,n){const r=Blake2b__default.default(64),o=new Uint8Array([a]);r.update(o),r.update(t);const s=e.G1.toUncompressed(i);r.update(s);const l=e.G1.toUncompressed(n);r.update(l);return hashToG2(e,r.digest())}function calculatePubKey(e,a,t,i,n){return e.g1_s=a.G1.toAffine(a.G1.fromRng(n)),e.g1_sx=a.G1.toAffine(a.G1.timesFr(e.g1_s,e.prvKey)),e.g2_sp=a.G2.toAffine(getG2sp(a,t,i,e.g1_s,e.g1_sx)),e.g2_spx=a.G2.toAffine(a.G2.timesFr(e.g2_sp,e.prvKey)),e}function createPTauKey(e,a,t){const i={tau:{},alpha:{},beta:{}};return i.tau.prvKey=e.Fr.fromRng(t),i.alpha.prvKey=e.Fr.fromRng(t),i.beta.prvKey=e.Fr.fromRng(t),calculatePubKey(i.tau,e,0,a,t),calculatePubKey(i.alpha,e,1,a,t),calculatePubKey(i.beta,e,2,a,t),i}async function writePTauHeader(e,a,t,i){i||(i=t),await e.writeULE32(1);const n=e.pos;await e.writeULE64(0),await e.writeULE32(8*a.F1.n64);const r=new Uint8Array(a.F1.n8);ffjavascript.Scalar.toRprLE(r,0,a.q,a.F1.n8),await e.write(r),await e.writeULE32(t),await e.writeULE32(i);const o=e.pos-n-8,s=e.pos;await e.writeULE64(o,n),e.pos=s}async function readPTauHeader(e,a){if(!a[1])throw new Error(e.fileName+": File has no  header");if(a[1].length>1)throw new Error(e.fileName+": File has more than one header");e.pos=a[1][0].p;const t=await e.readULE32(),i=await e.read(t),n=ffjavascript.Scalar.fromRprLE(i),r=await getCurveFromQ(n);if(8*r.F1.n64!=t)throw new Error(e.fileName+": Invalid size");const o=await e.readULE32(),s=await e.readULE32();if(e.pos-a[1][0].p!=a[1][0].size)throw new Error("Invalid PTau header size");return{curve:r,power:o,ceremonyPower:s}}async function readPtauPubKey(e,a,t){return fromPtauPubKeyRpr(await e.read(2*a.F1.n8*6+2*a.F2.n8*3),0,a,t)}function fromPtauPubKeyRpr(e,a,t,i){const n={tau:{},alpha:{},beta:{}};return n.tau.g1_s=r(),n.tau.g1_sx=r(),n.alpha.g1_s=r(),n.alpha.g1_sx=r(),n.beta.g1_s=r(),n.beta.g1_sx=r(),n.tau.g2_spx=o(),n.alpha.g2_spx=o(),n.beta.g2_spx=o(),n;function r(){let n;return n=i?t.G1.fromRprLEM(e,a):t.G1.fromRprUncompressed(e,a),a+=2*t.G1.F.n8,n}function o(){let n;return n=i?t.G2.fromRprLEM(e,a):t.G2.fromRprUncompressed(e,a),a+=2*t.G2.F.n8,n}}function toPtauPubKeyRpr(e,a,t,i,n){async function r(i){n?t.G1.toRprLEM(e,a,i):t.G1.toRprUncompressed(e,a,i),a+=2*t.F1.n8}async function o(i){n?t.G2.toRprLEM(e,a,i):t.G2.toRprUncompressed(e,a,i),a+=2*t.F2.n8}return r(i.tau.g1_s),r(i.tau.g1_sx),r(i.alpha.g1_s),r(i.alpha.g1_sx),r(i.beta.g1_s),r(i.beta.g1_sx),o(i.tau.g2_spx),o(i.alpha.g2_spx),o(i.beta.g2_spx),e}async function writePtauPubKey(e,a,t,i){const n=new Uint8Array(2*a.F1.n8*6+2*a.F2.n8*3);toPtauPubKeyRpr(n,0,a,t,i),await e.write(n)}async function readContribution(e,a){const t={};t.tauG1=await l(),t.tauG2=await c(),t.alphaG1=await l(),t.betaG1=await l(),t.betaG2=await c(),t.key=await readPtauPubKey(e,a,!0),t.partialHash=await e.read(216),t.nextChallenge=await e.read(64),t.type=await e.readULE32();const i=new Uint8Array(2*a.G1.F.n8*6+2*a.G2.F.n8*3);toPtauPubKeyRpr(i,0,a,t.key,!1);const n=Blake2b__default.default(64);n.setPartialHash(t.partialHash),n.update(i),t.responseHash=n.digest();const r=await e.readULE32(),o=e.pos;let s=0;for(;e.pos-o<r;){const e=await u(1);if(e[0]<=s)throw new Error("Parameters in the contribution must be sorted");if(s=e[0],1==e[0]){const e=await u(1),a=await u(e[0]);t.name=(new TextDecoder).decode(a)}else if(2==e[0]){const e=await u(1);t.numIterationsExp=e[0]}else{if(3!=e[0])throw new Error("Parameter not recognized");{const e=await u(1);t.beaconHash=await u(e[0])}}}if(e.pos!=o+r)throw new Error("Parametes do not match");return t;async function l(){const t=await e.read(2*a.G1.F.n8);return a.G1.fromRprLEM(t)}async function c(){const t=await e.read(2*a.G2.F.n8);return a.G2.fromRprLEM(t)}async function u(a){const t=await e.read(a);return new Uint8Array(t)}}async function readContributions(e,a,t){if(!t[7])throw new Error(e.fileName+": File has no  contributions");if(t[7][0].length>1)throw new Error(e.fileName+": File has more than one contributions section");e.pos=t[7][0].p;const i=await e.readULE32(),n=[];for(let r=0;r<i;r++){const t=await readContribution(e,a);t.id=r+1,n.push(t)}if(e.pos-t[7][0].p!=t[7][0].size)throw new Error("Invalid contribution section size");return n}async function writeContribution(e,a,t){const i=new Uint8Array(2*a.F1.n8),n=new Uint8Array(2*a.F2.n8);await o(t.tauG1),await s(t.tauG2),await o(t.alphaG1),await o(t.betaG1),await s(t.betaG2),await writePtauPubKey(e,a,t.key,!0),await e.write(t.partialHash),await e.write(t.nextChallenge),await e.writeULE32(t.type||0);const r=[];if(t.name){r.push(1);const e=new TextEncoder("utf-8").encode(t.name.substring(0,64));r.push(e.byteLength);for(let a=0;a<e.byteLength;a++)r.push(e[a])}if(1==t.type){r.push(2),r.push(t.numIterationsExp),r.push(3),r.push(t.beaconHash.byteLength);for(let e=0;e<t.beaconHash.byteLength;e++)r.push(t.beaconHash[e])}if(r.length>0){const a=new Uint8Array(r);await e.writeULE32(a.byteLength),await e.write(a)}else await e.writeULE32(0);async function o(t){a.G1.toRprLEM(i,0,t),await e.write(i)}async function s(t){a.G2.toRprLEM(n,0,t),await e.write(n)}}async function writeContributions(e,a,t){await e.writeULE32(7);const i=e.pos;await e.writeULE64(0),await e.writeULE32(t.length);for(let o=0;o<t.length;o++)await writeContribution(e,a,t[o]);const n=e.pos-i-8,r=e.pos;await e.writeULE64(n,i),e.pos=r}function calculateFirstChallengeHash(e,a,t){t&&t.debug("Calculating First Challenge Hash");const i=new Blake2b__default.default(64),n=new Uint8Array(2*e.G1.F.n8),r=new Uint8Array(2*e.G2.F.n8);let o;return e.G1.toRprUncompressed(n,0,e.G1.g),e.G2.toRprUncompressed(r,0,e.G2.g),i.update(Blake2b__default.default(64).digest()),o=2**a*2-1,t&&t.debug("Calculate Initial Hash: tauG1"),s(n,o),o=2**a,t&&t.debug("Calculate Initial Hash: tauG2"),s(r,o),t&&t.debug("Calculate Initial Hash: alphaTauG1"),s(n,o),t&&t.debug("Calculate Initial Hash: betaTauG1"),s(n,o),i.update(r),i.digest();function s(e,a){const n=5e5,r=Math.floor(a/n),o=a%n,s=new Uint8Array(n*e.byteLength);for(let t=0;t<n;t++)s.set(e,t*e.byteLength);for(let l=0;l<r;l++)i.update(s),t&&t.debug("Initial hash: "+l*n);for(let t=0;t<o;t++)i.update(e)}}function keyFromBeacon(e,a,t,i){return createPTauKey(e,a,rngFromBeaconParams(t,i))}async function newAccumulator(e,a,t,i){await Blake2b__default.default.ready();const n=await binFileUtils__namespace.createBinFile(t,"ptau",1,7);await writePTauHeader(n,e,a,0);const r=e.G1.oneAffine,o=e.G2.oneAffine;await binFileUtils__namespace.startWriteSection(n,2);const s=2**a*2-1;for(let d=0;d<s;d++)await n.write(r),i&&d%1e5==0&&d&&i.log("tauG1: "+d);await binFileUtils__namespace.endWriteSection(n),await binFileUtils__namespace.startWriteSection(n,3);const l=2**a;for(let d=0;d<l;d++)await n.write(o),i&&d%1e5==0&&d&&i.log("tauG2: "+d);await binFileUtils__namespace.endWriteSection(n),await binFileUtils__namespace.startWriteSection(n,4);const c=2**a;for(let d=0;d<c;d++)await n.write(r),i&&d%1e5==0&&d&&i.log("alphaTauG1: "+d);await binFileUtils__namespace.endWriteSection(n),await binFileUtils__namespace.startWriteSection(n,5);const u=2**a;for(let d=0;d<u;d++)await n.write(r),i&&d%1e5==0&&d&&i.log("betaTauG1: "+d);await binFileUtils__namespace.endWriteSection(n),await binFileUtils__namespace.startWriteSection(n,6),await n.write(o),await binFileUtils__namespace.endWriteSection(n),await binFileUtils__namespace.startWriteSection(n,7),await n.writeULE32(0),await binFileUtils__namespace.endWriteSection(n),await n.close();const f=calculateFirstChallengeHash(e,a,i);return i&&i.debug(formatHash(Blake2b__default.default(64).digest(),"Blank Contribution Hash:")),i&&i.info(formatHash(f,"First Contribution Hash:")),f}async function exportChallenge(e,a,t){await Blake2b__default.default.ready();const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:r,power:o}=await readPTauHeader(i,n),s=await readContributions(i,r,n);let l,c;0==s.length?(l=Blake2b__default.default(64).digest(),c=calculateFirstChallengeHash(r,o)):(l=s[s.length-1].responseHash,c=s[s.length-1].nextChallenge),t&&t.info(formatHash(l,"Last Response Hash: ")),t&&t.info(formatHash(c,"New Challenge Hash: "));const u=await fastFile__namespace.createOverride(a),f=Blake2b__default.default(64);await u.write(l),f.update(l),await w(2,"G1",2**o*2-1,"tauG1"),await w(3,"G2",2**o,"tauG2"),await w(4,"G1",2**o,"alphaTauG1"),await w(5,"G1",2**o,"betaTauG1"),await w(6,"G2",1,"betaG2"),await i.close(),await u.close();const d=f.digest();if(!hashIsEqual(c,d))throw t&&t.info(formatHash(d,"Calc Curret Challenge Hash: ")),t&&t.error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one"),new Error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one");return c;async function w(e,a,o,s){const l=r[a],c=2*l.F.n8,d=Math.floor((1<<24)/c);await binFileUtils__namespace.startReadUniqueSection(i,n,e);for(let n=0;n<o;n+=d){t&&t.debug(`Exporting ${s}: ${n}/${o}`);const e=Math.min(o-n,d);let a;a=await i.read(e*c),a=await l.batchLEMtoU(a),await u.write(a),f.update(a)}await binFileUtils__namespace.endReadSection(i)}}async function importResponse(e,a,t,i,n,r){await Blake2b__default.default.ready();const o=new Uint8Array(64);for(let x=0;x<64;x++)o[x]=255;const{fd:s,sections:l}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:c,power:u}=await readPTauHeader(s,l),f=await readContributions(s,c,l),d={};i&&(d.name=i);const w=2*c.F1.n8,p=c.F1.n8,m=2*c.F2.n8,b=c.F2.n8,g=await fastFile__namespace.readExisting(a);if(g.totalSize!=64+(2**u*2-1)*p+2**u*b+2**u*p+2**u*p+b+6*w+3*m)throw new Error("Size of the contribution is invalid");let h;h=f.length>0?f[f.length-1].nextChallenge:calculateFirstChallengeHash(c,u,r);const _=await binFileUtils__namespace.createBinFile(t,"ptau",1,n?7:2);await writePTauHeader(_,c,u);const y=await g.read(64);if(hashIsEqual(o,h)&&(h=y,f[f.length-1].nextChallenge=h),!hashIsEqual(y,h))throw new Error("Wrong contribution. this contribution is not based on the previus hash");const F=new Blake2b__default.default(64);F.update(y);const v=[];let G;G=await B(g,_,"G1",2,2**u*2-1,[1],"tauG1"),d.tauG1=G[0],G=await B(g,_,"G2",3,2**u,[1],"tauG2"),d.tauG2=G[0],G=await B(g,_,"G1",4,2**u,[0],"alphaG1"),d.alphaG1=G[0],G=await B(g,_,"G1",5,2**u,[0],"betaG1"),d.betaG1=G[0],G=await B(g,_,"G2",6,1,[0],"betaG2"),d.betaG2=G[0],d.partialHash=F.getPartialHash();const U=await g.read(2*c.F1.n8*6+2*c.F2.n8*3);d.key=fromPtauPubKeyRpr(U,0,c,!1),F.update(new Uint8Array(U));const S=F.digest();if(r&&r.info(formatHash(S,"Contribution Response Hash imported: ")),n){const e=new Blake2b__default.default(64);e.update(S),await E(e,_,"G1",2,2**u*2-1,"tauG1",r),await E(e,_,"G2",3,2**u,"tauG2",r),await E(e,_,"G1",4,2**u,"alphaTauG1",r),await E(e,_,"G1",5,2**u,"betaTauG1",r),await E(e,_,"G2",6,1,"betaG2",r),d.nextChallenge=e.digest(),r&&r.info(formatHash(d.nextChallenge,"Next Challenge Hash: "))}else d.nextChallenge=o;return f.push(d),await writeContributions(_,c,f),await g.close(),await _.close(),await s.close(),d.nextChallenge;async function B(e,a,t,i,o,s,l){return n?await async function(e,a,t,i,n,o,s){const l=c[t],u=l.F.n8,f=2*l.F.n8,d=[];await binFileUtils__namespace.startWriteSection(a,i);const w=Math.floor((1<<24)/f);v[i]=a.pos;for(let c=0;c<n;c+=w){r&&r.debug(`Importing ${s}: ${c}/${n}`);const t=Math.min(n-c,w),i=await e.read(t*u);F.update(i);const p=await l.batchCtoLEM(i);await a.write(p);for(let e=0;e<o.length;e++){const a=o[e];if(a>=c&&a<c+t){const e=l.fromRprLEM(p,(a-c)*f);d.push(e)}}}return await binFileUtils__namespace.endWriteSection(a),d}(e,a,t,i,o,s,l):await async function(e,a,t,i,n,o,s){const l=c[t],u=l.F.n8,f=[],d=Math.floor((1<<24)/u);for(let c=0;c<n;c+=d){r&&r.debug(`Importing ${s}: ${c}/${n}`);const a=Math.min(n-c,d),t=await e.read(a*u);F.update(t);for(let e=0;e<o.length;e++){const i=o[e];if(i>=c&&i<c+a){const e=l.fromRprCompressed(t,(i-c)*u);f.push(e)}}}return f}(e,0,t,0,o,s,l)}async function E(e,a,t,i,n,r,o){const s=c[t],l=2*s.F.n8,u=Math.floor((1<<24)/l),f=a.pos;a.pos=v[i];for(let c=0;c<n;c+=u){o&&o.debug(`Hashing ${r}: ${c}/${n}`);const t=Math.min(n-c,u),i=await a.read(t*l),f=await s.batchLEMtoU(i);e.update(f)}a.pos=f}}const sameRatio$1=sameRatio$2;async function verifyContribution(e,a,t,i){let n;if(1==a.type){const n=keyFromBeacon(e,t.nextChallenge,a.beaconHash,a.numIterationsExp);if(!e.G1.eq(a.key.tau.g1_s,n.tau.g1_s))return i&&i.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!e.G1.eq(a.key.tau.g1_sx,n.tau.g1_sx))return i&&i.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!e.G2.eq(a.key.tau.g2_spx,n.tau.g2_spx))return i&&i.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!e.G1.eq(a.key.alpha.g1_s,n.alpha.g1_s))return i&&i.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!e.G1.eq(a.key.alpha.g1_sx,n.alpha.g1_sx))return i&&i.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!e.G2.eq(a.key.alpha.g2_spx,n.alpha.g2_spx))return i&&i.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!e.G1.eq(a.key.beta.g1_s,n.beta.g1_s))return i&&i.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!e.G1.eq(a.key.beta.g1_sx,n.beta.g1_sx))return i&&i.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1;if(!e.G2.eq(a.key.beta.g2_spx,n.beta.g2_spx))return i&&i.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${a.id}  ${a.name||""}`),!1}return a.key.tau.g2_sp=e.G2.toAffine(getG2sp(e,0,t.nextChallenge,a.key.tau.g1_s,a.key.tau.g1_sx)),a.key.alpha.g2_sp=e.G2.toAffine(getG2sp(e,1,t.nextChallenge,a.key.alpha.g1_s,a.key.alpha.g1_sx)),a.key.beta.g2_sp=e.G2.toAffine(getG2sp(e,2,t.nextChallenge,a.key.beta.g1_s,a.key.beta.g1_sx)),n=await sameRatio$1(e,a.key.tau.g1_s,a.key.tau.g1_sx,a.key.tau.g2_sp,a.key.tau.g2_spx),!0!==n?(i&&i.error("INVALID key (tau) in challenge #"+a.id),!1):(n=await sameRatio$1(e,a.key.alpha.g1_s,a.key.alpha.g1_sx,a.key.alpha.g2_sp,a.key.alpha.g2_spx),!0!==n?(i&&i.error("INVALID key (alpha) in challenge #"+a.id),!1):(n=await sameRatio$1(e,a.key.beta.g1_s,a.key.beta.g1_sx,a.key.beta.g2_sp,a.key.beta.g2_spx),!0!==n?(i&&i.error("INVALID key (beta) in challenge #"+a.id),!1):(n=await sameRatio$1(e,t.tauG1,a.tauG1,a.key.tau.g2_sp,a.key.tau.g2_spx),!0!==n?(i&&i.error("INVALID tau*G1. challenge #"+a.id+" It does not follow the previous contribution"),!1):(n=await sameRatio$1(e,a.key.tau.g1_s,a.key.tau.g1_sx,t.tauG2,a.tauG2),!0!==n?(i&&i.error("INVALID tau*G2. challenge #"+a.id+" It does not follow the previous contribution"),!1):(n=await sameRatio$1(e,t.alphaG1,a.alphaG1,a.key.alpha.g2_sp,a.key.alpha.g2_spx),!0!==n?(i&&i.error("INVALID alpha*G1. challenge #"+a.id+" It does not follow the previous contribution"),!1):(n=await sameRatio$1(e,t.betaG1,a.betaG1,a.key.beta.g2_sp,a.key.beta.g2_spx),!0!==n?(i&&i.error("INVALID beta*G1. challenge #"+a.id+" It does not follow the previous contribution"),!1):(n=await sameRatio$1(e,a.key.beta.g1_s,a.key.beta.g1_sx,t.betaG2,a.betaG2),!0!==n?(i&&i.error("INVALID beta*G2. challenge #"+a.id+"It does not follow the previous contribution"),!1):(i&&i.info("Powers Of tau file OK!"),!0))))))))}async function verify(e,a){let t;await Blake2b__default.default.ready();const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:r,power:o,ceremonyPower:s}=await readPTauHeader(i,n),l=await readContributions(i,r,n);a&&a.debug("power: 2**"+o),a&&a.debug("Computing initial contribution hash");const c={tauG1:r.G1.g,tauG2:r.G2.g,alphaG1:r.G1.g,betaG1:r.G1.g,betaG2:r.G2.g,nextChallenge:calculateFirstChallengeHash(r,s,a),responseHash:Blake2b__default.default(64).digest()};if(0==l.length)return a&&a.error("This file has no contribution! It cannot be used in production"),!1;let u;u=l.length>1?l[l.length-2]:c;const f=l[l.length-1];a&&a.debug("Validating contribution #"+l[l.length-1].id);if(!await verifyContribution(r,f,u,a))return!1;const d=Blake2b__default.default(64);d.update(f.responseHash),a&&a.debug("Verifying powers in tau*G1 section");const w=await y(2,"G1","tauG1",2**o*2-1,[0,1],a);if(t=await sameRatio$1(r,w.R1,w.R2,r.G2.g,f.tauG2),!0!==t)return a&&a.error("tauG1 section. Powers do not match"),!1;if(!r.G1.eq(r.G1.g,w.singularPoints[0]))return a&&a.error("First element of tau*G1 section must be the generator"),!1;if(!r.G1.eq(f.tauG1,w.singularPoints[1]))return a&&a.error("Second element of tau*G1 section does not match the one in the contribution section"),!1;a&&a.debug("Verifying powers in tau*G2 section");const p=await y(3,"G2","tauG2",2**o,[0,1],a);if(t=await sameRatio$1(r,r.G1.g,f.tauG1,p.R1,p.R2),!0!==t)return a&&a.error("tauG2 section. Powers do not match"),!1;if(!r.G2.eq(r.G2.g,p.singularPoints[0]))return a&&a.error("First element of tau*G2 section must be the generator"),!1;if(!r.G2.eq(f.tauG2,p.singularPoints[1]))return a&&a.error("Second element of tau*G2 section does not match the one in the contribution section"),!1;a&&a.debug("Verifying powers in alpha*tau*G1 section");const m=await y(4,"G1","alphatauG1",2**o,[0],a);if(t=await sameRatio$1(r,m.R1,m.R2,r.G2.g,f.tauG2),!0!==t)return a&&a.error("alphaTauG1 section. Powers do not match"),!1;if(!r.G1.eq(f.alphaG1,m.singularPoints[0]))return a&&a.error("First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section"),!1;a&&a.debug("Verifying powers in beta*tau*G1 section");const b=await y(5,"G1","betatauG1",2**o,[0],a);if(t=await sameRatio$1(r,b.R1,b.R2,r.G2.g,f.tauG2),!0!==t)return a&&a.error("betaTauG1 section. Powers do not match"),!1;if(!r.G1.eq(f.betaG1,b.singularPoints[0]))return a&&a.error("First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section"),!1;const g=await async function(e){const a=r.G2,t=2*a.F.n8,o=new Uint8Array(t);if(!n[6])throw e.error("File has no BetaG2 section"),new Error("File has no BetaG2 section");if(n[6].length>1)throw e.error("File has no BetaG2 section"),new Error("File has more than one GetaG2 section");i.pos=n[6][0].p;const s=await i.read(t),l=a.fromRprLEM(s);return a.toRprUncompressed(o,0,l),d.update(o),l}(a);if(!r.G2.eq(f.betaG2,g))return a&&a.error("betaG2 element in betaG2 section does not match the one in the contribution section"),!1;const h=d.digest();if(o==s&&!hashIsEqual(h,f.nextChallenge))return a&&a.error("Hash of the values does not match the next challenge of the last contributor in the contributions section"),!1;a&&a.info(formatHash(h,"Next challenge hash: ")),_(f,u);for(let v=l.length-2;v>=0;v--){const e=l[v],t=v>0?l[v-1]:c;if(!await verifyContribution(r,e,t,a))return!1;_(e,t)}if(a&&a.info("-----------------------------------------------------"),n[12]&&n[13]&&n[14]&&n[15]){let e;if(e=await F("G1",2,12,"tauG1",a),!e)return!1;if(e=await F("G2",3,13,"tauG2",a),!e)return!1;if(e=await F("G1",4,14,"alphaTauG1",a),!e)return!1;if(e=await F("G1",5,15,"betaTauG1",a),!e)return!1}else a&&a.warn('this file does not contain phase2 precalculated values. Please run: \n   snarkjs "powersoftau preparephase2" to prepare this file to be used in the phase2 ceremony.');return await i.close(),a&&a.info("Powers of Tau Ok!"),!0;function _(e,t){if(!a)return;a.info("-----------------------------------------------------"),a.info(`Contribution #${e.id}: ${e.name||""}`),a.info(formatHash(e.nextChallenge,"Next Challenge: "));const i=new Uint8Array(2*r.G1.F.n8*6+2*r.G2.F.n8*3);toPtauPubKeyRpr(i,0,r,e.key,!1);const n=Blake2b__default.default(64);n.setPartialHash(e.partialHash),n.update(i);const o=n.digest();a.info(formatHash(o,"Response Hash:")),a.info(formatHash(t.nextChallenge,"Response Hash:")),1==e.type&&(a.info(`Beacon generator: ${byteArray2hex(e.beaconHash)}`),a.info(`Beacon iterations Exp: ${e.numIterationsExp}`))}async function y(e,a,t,o,s,l){const c=r[a],u=2*c.F.n8;await binFileUtils__namespace.startReadUniqueSection(i,n,e);const f=[];let w=c.zero,p=c.zero,m=c.zero;for(let n=0;n<o;n+=65536){l&&l.debug(`points relations: ${t}: ${n}/${o} `);const e=Math.min(o-n,65536),a=await i.read(e*u),r=await c.batchLEMtoU(a);d.update(r);const b=new Uint8Array(4*(e-1));if(crypto__default.default.randomFillSync(b),n>0){const e=c.fromRprLEM(a,0),t=crypto__default.default.randomBytes(4).readUInt32BE(0,!0);w=c.add(w,c.timesScalar(m,t)),p=c.add(p,c.timesScalar(e,t))}const g=await c.multiExpAffine(a.slice(0,(e-1)*u),b),h=await c.multiExpAffine(a.slice(u),b);w=c.add(w,g),p=c.add(p,h),m=c.fromRprLEM(a,(e-1)*u);for(let t=0;t<s.length;t++){const i=s[t];if(i>=n&&i<n+e){const e=c.fromRprLEM(a,(i-n)*u);f.push(e)}}}return await binFileUtils__namespace.endReadSection(i),{R1:w,R2:p,singularPoints:f}}async function F(e,a,t,s,l){l&&l.debug(`Verifying phase2 calculated values ${s}...`);const c=r[e],u=2*c.F.n8,f=new Array(8);for(let i=0;i<8;i++)f[i]=crypto__default.default.randomBytes(4).readUInt32BE(0,!0);for(let i=0;i<=o;i++){if(!await d(i))return!1}if(2==a){if(!await d(o+1))return!1}return!0;async function d(e){l&&l.debug(`Power ${e}...`);const d=r.Fr.n8,w=2**e;let p,m=new Uint32Array(w),b=new ffjavascript.ChaCha(f);l&&l.debug(`Creating random numbers Powers${e}...`);for(let a=0;a<w;a++)m[a]=e==o+1&&a==w-1?0:b.nextU32();m=new Uint8Array(m.buffer,m.byteOffset,m.byteLength),l&&l.debug(`reading points Powers${e}...`),await binFileUtils__namespace.startReadUniqueSection(i,n,a),p=new ffjavascript.BigBuffer(w*u),e==o+1?(await i.readToBuffer(p,0,(w-1)*u),p.set(r.G1.zeroAffine,(w-1)*u)):await i.readToBuffer(p,0,w*u),await binFileUtils__namespace.endReadSection(i,!0);const g=await c.multiExpAffine(p,m,l,s+"_"+e);m=new ffjavascript.BigBuffer(w*d),b=new ffjavascript.ChaCha(f);const h=new Uint8Array(4),_=new DataView(h.buffer);l&&l.debug(`Creating random numbers Powers${e}...`);for(let a=0;a<w;a++)a==w-1&&e==o+1||(_.setUint32(0,b.nextU32(),!0),m.set(h,a*d));l&&l.debug(`batchToMontgomery ${e}...`),m=await r.Fr.batchToMontgomery(m),l&&l.debug(`fft ${e}...`),m=await r.Fr.fft(m),l&&l.debug(`batchFromMontgomery ${e}...`),m=await r.Fr.batchFromMontgomery(m),l&&l.debug(`reading points Lagrange${e}...`),await binFileUtils__namespace.startReadUniqueSection(i,n,t),i.pos+=u*(2**e-1),await i.readToBuffer(p,0,w*u),await binFileUtils__namespace.endReadSection(i,!0);const y=await c.multiExpAffine(p,m,l,s+"_"+e+"_transformed");return!!c.eq(g,y)||(l&&l.error("Phase2 caclutation does not match with powers of tau"),!1)}}}async function applyKeyToSection(e,a,t,i,n,r,o,s,l,c){const u=n[r],f=2*u.F.n8,d=a[i][0].size/f;await binFileUtils__namespace.startReadUniqueSection(e,a,i),await binFileUtils__namespace.startWriteSection(t,i);let w=o;for(let p=0;p<d;p+=65536){c&&c.debug(`Applying key: ${l}: ${p}/${d}`);const a=Math.min(d-p,65536);let i;i=await e.read(a*f),i=await u.batchApplyKey(i,w,s),await t.write(i),w=n.Fr.mul(w,n.Fr.exp(s,a))}await binFileUtils__namespace.endWriteSection(t),await binFileUtils__namespace.endReadSection(e)}async function applyKeyToChallengeSection(e,a,t,i,n,r,o,s,l,c,u){const f=i[n],d=2*f.F.n8,w=Math.floor((1<<20)/d);let p=o;for(let m=0;m<r;m+=w){u&&u.debug(`Applying key ${c}: ${m}/${r}`);const n=Math.min(r-m,w),o=await e.read(n*d),b=await f.batchUtoLEM(o),g=await f.batchApplyKey(b,p,s);let h;h="COMPRESSED"==l?await f.batchLEMtoC(g):await f.batchLEMtoU(g),t&&t.update(h),await a.write(h),p=i.Fr.mul(p,i.Fr.exp(s,n))}}async function challengeContribute(e,a,t,i,n){await Blake2b__default.default.ready();const r=await fastFile__namespace.readExisting(a),o=8*e.F1.n64*2,s=8*e.F2.n64*2,l=(r.totalSize+o-64-s)/(4*o+s);let c=l,u=0;for(;c>1;)c/=2,u+=1;if(2**u!=l)throw new Error("Invalid file size");n&&n.debug("Power to tau size: "+u);const f=await getRandomRng(i),d=await fastFile__namespace.createOverride(t),w=Blake2b__default.default(64);for(let y=0;y<r.totalSize;y+=r.pageSize){n&&n.debug(`Hashing challenge ${y}/${r.totalSize}`);const e=Math.min(r.totalSize-y,r.pageSize),a=await r.read(e);w.update(a)}const p=await r.read(64,0);n&&n.info(formatHash(p,"Claimed Previous Response Hash: "));const m=w.digest();n&&n.info(formatHash(m,"Current Challenge Hash: "));const b=createPTauKey(e,m,f);n&&["tau","alpha","beta"].forEach((a=>{n.debug(a+".g1_s: "+e.G1.toString(b[a].g1_s,16)),n.debug(a+".g1_sx: "+e.G1.toString(b[a].g1_sx,16)),n.debug(a+".g2_sp: "+e.G2.toString(b[a].g2_sp,16)),n.debug(a+".g2_spx: "+e.G2.toString(b[a].g2_spx,16)),n.debug("")}));const g=Blake2b__default.default(64);await d.write(m),g.update(m),await applyKeyToChallengeSection(r,d,g,e,"G1",2**u*2-1,e.Fr.one,b.tau.prvKey,"COMPRESSED","tauG1",n),await applyKeyToChallengeSection(r,d,g,e,"G2",2**u,e.Fr.one,b.tau.prvKey,"COMPRESSED","tauG2",n),await applyKeyToChallengeSection(r,d,g,e,"G1",2**u,b.alpha.prvKey,b.tau.prvKey,"COMPRESSED","alphaTauG1",n),await applyKeyToChallengeSection(r,d,g,e,"G1",2**u,b.beta.prvKey,b.tau.prvKey,"COMPRESSED","betaTauG1",n),await applyKeyToChallengeSection(r,d,g,e,"G2",1,b.beta.prvKey,b.tau.prvKey,"COMPRESSED","betaTauG2",n);const h=new Uint8Array(2*e.F1.n8*6+2*e.F2.n8*3);toPtauPubKeyRpr(h,0,e,b,!1),await d.write(h),g.update(h);const _=g.digest();n&&n.info(formatHash(_,"Contribution Response Hash: ")),await d.close(),await r.close()}async function beacon$1(e,a,t,i,n,r){const o=hex2ByteArray(i);if(0==o.byteLength||2*o.byteLength!=i.length)return r&&r.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(o.length>=256)return r&&r.error("Maximum lenght of beacon hash is 255 bytes"),!1;if((n=parseInt(n))<10||n>63)return r&&r.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;await Blake2b__default.default.ready();const{fd:s,sections:l}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:c,power:u,ceremonyPower:f}=await readPTauHeader(s,l);if(u!=f)return r&&r.error("This file has been reduced. You cannot contribute into a reduced file."),!1;l[12]&&r&&r.warn("Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");const d=await readContributions(s,c,l),w={name:t,type:1,numIterationsExp:n,beaconHash:o};let p;p=d.length>0?d[d.length-1].nextChallenge:calculateFirstChallengeHash(c,u,r),w.key=keyFromBeacon(c,p,o,n);const m=new Blake2b__default.default(64);m.update(p);const b=await binFileUtils__namespace.createBinFile(a,"ptau",1,7);await writePTauHeader(b,c,u);const g=[];let h;h=await v(2,"G1",2**u*2-1,c.Fr.e(1),w.key.tau.prvKey,"tauG1",r),w.tauG1=h[1],h=await v(3,"G2",2**u,c.Fr.e(1),w.key.tau.prvKey,"tauG2",r),w.tauG2=h[1],h=await v(4,"G1",2**u,w.key.alpha.prvKey,w.key.tau.prvKey,"alphaTauG1",r),w.alphaG1=h[0],h=await v(5,"G1",2**u,w.key.beta.prvKey,w.key.tau.prvKey,"betaTauG1",r),w.betaG1=h[0],h=await v(6,"G2",1,w.key.beta.prvKey,w.key.tau.prvKey,"betaTauG2",r),w.betaG2=h[0],w.partialHash=m.getPartialHash();const _=new Uint8Array(2*c.F1.n8*6+2*c.F2.n8*3);toPtauPubKeyRpr(_,0,c,w.key,!1),m.update(new Uint8Array(_));const y=m.digest();r&&r.info(formatHash(y,"Contribution Response Hash imported: "));const F=new Blake2b__default.default(64);return F.update(y),await G(b,"G1",2,2**u*2-1,"tauG1",r),await G(b,"G2",3,2**u,"tauG2",r),await G(b,"G1",4,2**u,"alphaTauG1",r),await G(b,"G1",5,2**u,"betaTauG1",r),await G(b,"G2",6,1,"betaG2",r),w.nextChallenge=F.digest(),r&&r.info(formatHash(w.nextChallenge,"Next Challenge Hash: ")),d.push(w),await writeContributions(b,c,d),await s.close(),await b.close(),y;async function v(e,a,t,i,n,r,o){const u=[];s.pos=l[e][0].p,await binFileUtils__namespace.startWriteSection(b,e),g[e]=b.pos;const f=c[a],d=2*f.F.n8,w=Math.floor((1<<20)/d);let p=i;for(let l=0;l<t;l+=w){o&&o.debug(`applying key${r}: ${l}/${t}`);const e=Math.min(t-l,w),a=await s.read(e*d),i=await f.batchApplyKey(a,p,n),g=b.write(i),h=await f.batchLEMtoC(i);if(m.update(h),await g,0==l)for(let n=0;n<Math.min(2,t);n++)u.push(f.fromRprLEM(i,n*d));p=c.Fr.mul(p,c.Fr.exp(n,e))}return await binFileUtils__namespace.endWriteSection(b),u}async function G(e,a,t,i,n,r){const o=c[a],s=2*o.F.n8,l=Math.floor((1<<24)/s),u=e.pos;e.pos=g[t];for(let c=0;c<i;c+=l){r&&r.debug(`Hashing ${n}: ${c}/${i}`);const a=Math.min(i-c,l),t=await e.read(a*s),u=await o.batchLEMtoU(t);F.update(u)}e.pos=u}}async function contribute(e,a,t,i,n){await Blake2b__default.default.ready();const{fd:r,sections:o}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:s,power:l,ceremonyPower:c}=await readPTauHeader(r,o);if(l!=c)throw n&&n.error("This file has been reduced. You cannot contribute into a reduced file."),new Error("This file has been reduced. You cannot contribute into a reduced file.");o[12]&&n&&n.warn("WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");const u=await readContributions(r,s,o),f={name:t,type:0};let d;const w=await getRandomRng(i);d=u.length>0?u[u.length-1].nextChallenge:calculateFirstChallengeHash(s,l,n),f.key=createPTauKey(s,d,w);const p=new Blake2b__default.default(64);p.update(d);const m=await binFileUtils__namespace.createBinFile(a,"ptau",1,7);await writePTauHeader(m,s,l);const b=[];let g;g=await F(2,"G1",2**l*2-1,s.Fr.e(1),f.key.tau.prvKey,"tauG1"),f.tauG1=g[1],g=await F(3,"G2",2**l,s.Fr.e(1),f.key.tau.prvKey,"tauG2"),f.tauG2=g[1],g=await F(4,"G1",2**l,f.key.alpha.prvKey,f.key.tau.prvKey,"alphaTauG1"),f.alphaG1=g[0],g=await F(5,"G1",2**l,f.key.beta.prvKey,f.key.tau.prvKey,"betaTauG1"),f.betaG1=g[0],g=await F(6,"G2",1,f.key.beta.prvKey,f.key.tau.prvKey,"betaTauG2"),f.betaG2=g[0],f.partialHash=p.getPartialHash();const h=new Uint8Array(2*s.F1.n8*6+2*s.F2.n8*3);toPtauPubKeyRpr(h,0,s,f.key,!1),p.update(new Uint8Array(h));const _=p.digest();n&&n.info(formatHash(_,"Contribution Response Hash imported: "));const y=new Blake2b__default.default(64);return y.update(_),await v(m,"G1",2,2**l*2-1,"tauG1"),await v(m,"G2",3,2**l,"tauG2"),await v(m,"G1",4,2**l,"alphaTauG1"),await v(m,"G1",5,2**l,"betaTauG1"),await v(m,"G2",6,1,"betaG2"),f.nextChallenge=y.digest(),n&&n.info(formatHash(f.nextChallenge,"Next Challenge Hash: ")),u.push(f),await writeContributions(m,s,u),await r.close(),await m.close(),_;async function F(e,a,t,i,l,c){const u=[];r.pos=o[e][0].p,await binFileUtils__namespace.startWriteSection(m,e),b[e]=m.pos;const f=s[a],d=2*f.F.n8,w=Math.floor((1<<20)/d);let g=i;for(let o=0;o<t;o+=w){n&&n.debug(`processing: ${c}: ${o}/${t}`);const e=Math.min(t-o,w),a=await r.read(e*d),i=await f.batchApplyKey(a,g,l),b=m.write(i),h=await f.batchLEMtoC(i);if(p.update(h),await b,0==o)for(let n=0;n<Math.min(2,t);n++)u.push(f.fromRprLEM(i,n*d));g=s.Fr.mul(g,s.Fr.exp(l,e))}return await binFileUtils__namespace.endWriteSection(m),u}async function v(e,a,t,i,r){const o=s[a],l=2*o.F.n8,c=Math.floor((1<<24)/l),u=e.pos;e.pos=b[t];for(let s=0;s<i;s+=c){n&&s&&n.debug(`Hashing ${r}: `+s);const a=Math.min(i-s,c),t=await e.read(a*l),u=await o.batchLEMtoU(t);y.update(u)}e.pos=u}}async function preparePhase2(e,a,t){const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:r,power:o}=await readPTauHeader(i,n),s=await binFileUtils__namespace.createBinFile(a,"ptau",1,11);return await writePTauHeader(s,r,o),await binFileUtils__namespace.copySection(i,n,s,2),await binFileUtils__namespace.copySection(i,n,s,3),await binFileUtils__namespace.copySection(i,n,s,4),await binFileUtils__namespace.copySection(i,n,s,5),await binFileUtils__namespace.copySection(i,n,s,6),await binFileUtils__namespace.copySection(i,n,s,7),await l(2,12,"G1","tauG1"),await l(3,13,"G2","tauG2"),await l(4,14,"G1","alphaTauG1"),await l(5,15,"G1","betaTauG1"),await i.close(),void await s.close();async function l(e,a,l,c){t&&t.debug("Starting section: "+c),await binFileUtils__namespace.startWriteSection(s,a);for(let t=0;t<=o;t++)await u(t);async function u(a){const u=2**a,f=r[l];r.Fr;const d=2*f.F.n8;let w;f.F.n8,w=new ffjavascript.BigBuffer(u*d),await binFileUtils__namespace.startReadUniqueSection(i,n,e),2==e&&a==o+1?(await i.readToBuffer(w,0,(u-1)*d),w.set(r.G1.zeroAffine,(u-1)*d)):await i.readToBuffer(w,0,u*d),await binFileUtils__namespace.endReadSection(i,!0),w=await f.lagrangeEvaluations(w,"affine","affine",t,c),await s.write(w)}2==e&&await u(o+1),await binFileUtils__namespace.endWriteSection(s)}}async function truncate(e,a,t){const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:r,power:o,ceremonyPower:s}=await readPTauHeader(i,n),l=2*r.G1.F.n8,c=2*r.G2.F.n8;for(let f=1;f<o;f++)await u(f);return await i.close(),!0;async function u(e){let o=e.toString();for(;o.length<2;)o="0"+o;t&&t.debug("Writing Power: "+o);const u=await binFileUtils__namespace.createBinFile(a+o+".ptau","ptau",1,11);await writePTauHeader(u,r,e,s),await binFileUtils__namespace.copySection(i,n,u,2,(2**e*2-1)*l),await binFileUtils__namespace.copySection(i,n,u,3,2**e*c),await binFileUtils__namespace.copySection(i,n,u,4,2**e*l),await binFileUtils__namespace.copySection(i,n,u,5,2**e*l),await binFileUtils__namespace.copySection(i,n,u,6,c),await binFileUtils__namespace.copySection(i,n,u,7),await binFileUtils__namespace.copySection(i,n,u,12,(2**(e+1)*2-1)*l),await binFileUtils__namespace.copySection(i,n,u,13,(2**e*2-1)*c),await binFileUtils__namespace.copySection(i,n,u,14,(2**e*2-1)*l),await binFileUtils__namespace.copySection(i,n,u,15,(2**e*2-1)*l),await u.close()}}async function convert(e,a,t){const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:r,power:o}=await readPTauHeader(i,n),s=await binFileUtils__namespace.createBinFile(a,"ptau",1,11);return await writePTauHeader(s,r,o),await binFileUtils__namespace.copySection(i,n,s,2),await binFileUtils__namespace.copySection(i,n,s,3),await binFileUtils__namespace.copySection(i,n,s,4),await binFileUtils__namespace.copySection(i,n,s,5),await binFileUtils__namespace.copySection(i,n,s,6),await binFileUtils__namespace.copySection(i,n,s,7),await async function(e,a,l,c){t&&t.debug("Starting section: "+c);await binFileUtils__namespace.startWriteSection(s,a);const u=n[a][0].size,f=i.pageSize;await binFileUtils__namespace.startReadUniqueSection(i,n,a);for(let t=0;t<u;t+=f){const e=Math.min(u-t,f),a=await i.read(e);await s.write(a)}await binFileUtils__namespace.endReadSection(i),2==e&&await async function(a){const u=2**a,f=r[l],d=2*f.F.n8;let w;w=new ffjavascript.BigBuffer(u*d),await binFileUtils__namespace.startReadUniqueSection(i,n,e),2==e&&a==o+1?(await i.readToBuffer(w,0,(u-1)*d),w.set(r.G1.zeroAffine,(u-1)*d)):await i.readToBuffer(w,0,u*d);await binFileUtils__namespace.endReadSection(i,!0),w=await f.lagrangeEvaluations(w,"affine","affine",t,c),await s.write(w)}(o+1);await binFileUtils__namespace.endWriteSection(s)}(2,12,"G1","tauG1"),await binFileUtils__namespace.copySection(i,n,s,13),await binFileUtils__namespace.copySection(i,n,s,14),await binFileUtils__namespace.copySection(i,n,s,15),await i.close(),void await s.close()}async function exportJson(e,a){const{fd:t,sections:i}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:n,power:r}=await readPTauHeader(t,i),o={};return o.q=n.q,o.power=r,o.contributions=await readContributions(t,n,i),o.tauG1=await s(2,"G1",2**r*2-1,"tauG1"),o.tauG2=await s(3,"G2",2**r,"tauG2"),o.alphaTauG1=await s(4,"G1",2**r,"alphaTauG1"),o.betaTauG1=await s(5,"G1",2**r,"betaTauG1"),o.betaG2=await s(6,"G2",1,"betaG2"),o.lTauG1=await l(12,"G1","lTauG1"),o.lTauG2=await l(13,"G2","lTauG2"),o.lAlphaTauG1=await l(14,"G1","lAlphaTauG2"),o.lBetaTauG1=await l(15,"G1","lBetaTauG2"),await t.close(),o;async function s(e,r,o,s){const l=n[r],c=2*l.F.n8,u=[];await binFileUtils__namespace.startReadUniqueSection(t,i,e);for(let i=0;i<o;i++){a&&i&&i%1e4==0&&console.log(`${s}: `+i);const e=await t.read(c);u.push(l.fromRprLEM(e,0))}return await binFileUtils__namespace.endReadSection(t),u}async function l(e,o,s){const l=n[o],c=2*l.F.n8,u=[];await binFileUtils__namespace.startReadUniqueSection(t,i,e);for(let i=0;i<=r;i++){a&&console.log(`${s}: Power: ${i}`),u[i]=[];const e=2**i;for(let n=0;n<e;n++){a&&n&&n%1e4==0&&console.log(`${s}: ${n}/${e}`);const r=await t.read(c);u[i].push(l.fromRprLEM(r,0))}}return await binFileUtils__namespace.endReadSection(t),u}}var powersoftau=Object.freeze({__proto__:null,newAccumulator:newAccumulator,exportChallenge:exportChallenge,importResponse:importResponse,verify:verify,challengeContribute:challengeContribute,beacon:beacon$1,contribute:contribute,preparePhase2:preparePhase2,truncate:truncate,convert:convert,exportJson:exportJson});function r1csPrint(e,a,t){for(let n=0;n<e.constraints.length;n++)i(e.constraints[n]);function i(i){const n=t=>{let i="";return Object.keys(t).forEach((n=>{let r=a.varIdx2Name[n];"one"==r&&(r="");let o=e.curve.Fr.toString(t[n]);"1"==o&&(o=""),"-1"==o&&(o="-"),""!=i&&"-"!=o[0]&&(o="+"+o),""!=i&&(o=" "+o),i=i+o+r})),i},r=`[ ${n(i[0])} ] * [ ${n(i[1])} ] - [ ${n(i[2])} ] = 0`;t&&t.info(r)}}const bls12381r=ffjavascript.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),bn128r=ffjavascript.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");async function r1csInfo(e,a){const t=await r1csfile.readR1cs(e);return ffjavascript.Scalar.eq(t.prime,bn128r)?a&&a.info("Curve: bn-128"):ffjavascript.Scalar.eq(t.prime,bls12381r)?a&&a.info("Curve: bls12-381"):a&&a.info(`Unknown Curve. Prime: ${ffjavascript.Scalar.toString(t.prime)}`),a&&a.info(`# of Wires: ${t.nVars}`),a&&a.info(`# of Constraints: ${t.nConstraints}`),a&&a.info(`# of Private Inputs: ${t.nPrvInputs}`),a&&a.info(`# of Public Inputs: ${t.nPubInputs}`),a&&a.info(`# of Labels: ${t.nLabels}`),a&&a.info(`# of Outputs: ${t.nOutputs}`),t}function stringifyBigInts$2(e,a){if(a instanceof Uint8Array)return e.toString(a);if(Array.isArray(a))return a.map(stringifyBigInts$2.bind(null,e));if("object"==typeof a){const t={};return Object.keys(a).forEach((i=>{t[i]=stringifyBigInts$2(e,a[i])})),t}return"bigint"==typeof a||void 0!==a.eq?a.toString(10):a}async function r1csExportJson(e,a){const t=await r1csfile.readR1cs(e,!0,!0,!0,a),i=t.curve.Fr;return delete t.curve,stringifyBigInts$2(i,t)}var r1cs=Object.freeze({__proto__:null,print:r1csPrint,info:r1csInfo,exportJson:r1csExportJson});async function loadSymbols(e){const a={labelIdx2Name:["one"],varIdx2Name:["one"],componentIdx2Name:[]},t=await fastFile__namespace.readExisting(e),i=await t.read(t.totalSize),n=new TextDecoder("utf-8").decode(i).split("\n");for(let o=0;o<n.length;o++){const e=n[o].split(",");4==e.length&&(a.varIdx2Name[e[1]]?a.varIdx2Name[e[1]]+="|"+e[3]:a.varIdx2Name[e[1]]=e[3],a.labelIdx2Name[e[0]]=e[3],a.componentIdx2Name[e[2]]||(a.componentIdx2Name[e[2]]=r(e[3])))}return await t.close(),a;function r(e){const a=e.split(".");return a.pop(),a.join(".")}}async function wtnsDebug(e,a,t,i,n,r){const o=await fastFile__namespace.readExisting(a),s=await o.read(o.totalSize);await o.close();let l={sanityCheck:!0},c=await loadSymbols(i);n.set&&(c||(c=await loadSymbols(i)),l.logSetSignal=function(e,a){r&&r.info("SET "+c.labelIdx2Name[e]+" <-- "+a.toString())}),n.get&&(c||(c=await loadSymbols(i)),l.logGetSignal=function(e,a){r&&r.info("GET "+c.labelIdx2Name[e]+" --\x3e "+a.toString())}),n.trigger&&(c||(c=await loadSymbols(i)),l.logStartComponent=function(e){r&&r.info("START: "+c.componentIdx2Name[e])},l.logFinishComponent=function(e){r&&r.info("FINISH: "+c.componentIdx2Name[e])}),l.sym=c;const u=await circom_runtime.WitnessCalculatorBuilder(s,l),f=await u.calculateWitness(e),d=await binFileUtils__namespace.createBinFile(t,"wtns",2,2);await write(d,f,u.prime),await d.close()}async function wtnsExportJson(e){return await read(e)}var wtns=Object.freeze({__proto__:null,calculate:wtnsCalculate,debug:wtnsDebug,exportJson:wtnsExportJson});const SUBARRAY_SIZE=262144,BigArrayHandler={get:function(e,a){return isNaN(a)?e[a]:e.getElement(a)},set:function(e,a,t){return isNaN(a)?(e[a]=t,!0):e.setElement(a,t)}};class _BigArray{constructor(e){this.length=e||0,this.arr=new Array(262144);for(let a=0;a<e;a+=262144)this.arr[a/262144]=new Array(Math.min(262144,e-a));return this}push(){for(let e=0;e<arguments.length;e++)this.setElement(this.length,arguments[e])}slice(e,a){const t=new Array(a-e);for(let i=e;i<a;i++)t[i-e]=this.getElement(i);return t}getElement(e){e=parseInt(e);const a=Math.floor(e/262144),t=e%262144;return this.arr[a]?this.arr[a][t]:void 0}setElement(e,a){e=parseInt(e);const t=Math.floor(e/262144);this.arr[t]||(this.arr[t]=new Array(262144));const i=e%262144;return this.arr[t][i]=a,e>=this.length&&(this.length=e+1),!0}getKeys(){const e=new BigArray;for(let a=0;a<this.arr.length;a++)if(this.arr[a])for(let t=0;t<this.arr[a].length;t++)"undefined"!==typeof this.arr[a][t]&&e.push(262144*a+t);return e}}class BigArray{constructor(e){const a=new _BigArray(e);return new Proxy(a,BigArrayHandler)}}async function newZKey(e,a,t,i){await Blake2b__default.default.ready();const n=Blake2b__default.default(64),{fd:r,sections:o}=await binFileUtils.readBinFile(a,"ptau",1,1<<22,1<<24),{curve:s,power:l}=await readPTauHeader(r,o),{fd:c,sections:u}=await binFileUtils.readBinFile(e,"r1cs",1,1<<22,1<<24),f=await r1csfile.readR1csHeader(c,u,!1),d=await binFileUtils.createBinFile(t,"zkey",1,10,1<<22,1<<24),w=2*s.G1.F.n8,p=2*s.G2.F.n8;if(f.prime!=s.r)return i&&i.error("r1cs curve does not match powers of tau ceremony curve"),-1;const m=log2(f.nConstraints+f.nPubInputs+f.nOutputs+1-1)+1;if(m>l)return i&&i.error(`circuit too big for this power of tau ceremony. ${f.nConstraints}*2 > 2**${l}`),-1;if(!o[12])return i&&i.error("Powers of tau is not prepared."),-1;const b=f.nOutputs+f.nPubInputs,g=2**m;await binFileUtils.startWriteSection(d,1),await d.writeULE32(1),await binFileUtils.endWriteSection(d),await binFileUtils.startWriteSection(d,2);const h=s.q,_=8*(Math.floor((ffjavascript.Scalar.bitLength(h)-1)/64)+1),y=s.r,F=8*(Math.floor((ffjavascript.Scalar.bitLength(y)-1)/64)+1),v=ffjavascript.Scalar.mod(ffjavascript.Scalar.shl(1,8*F),y),G=s.Fr.e(ffjavascript.Scalar.mod(ffjavascript.Scalar.mul(v,v),y));let U,S,B;await d.writeULE32(_),await binFileUtils.writeBigInt(d,h,_),await d.writeULE32(F),await binFileUtils.writeBigInt(d,y,F),await d.writeULE32(f.nVars),await d.writeULE32(b),await d.writeULE32(g),U=await r.read(w,o[4][0].p),await d.write(U),U=await s.G1.batchLEMtoU(U),n.update(U),S=await r.read(w,o[5][0].p),await d.write(S),S=await s.G1.batchLEMtoU(S),n.update(S),B=await r.read(p,o[6][0].p),await d.write(B),B=await s.G2.batchLEMtoU(B),n.update(B);const E=new Uint8Array(w);s.G1.toRprLEM(E,0,s.G1.g);const x=new Uint8Array(p);s.G2.toRprLEM(x,0,s.G2.g);const A=new Uint8Array(w);s.G1.toRprUncompressed(A,0,s.G1.g);const k=new Uint8Array(p);s.G2.toRprUncompressed(k,0,s.G2.g),await d.write(x),await d.write(E),await d.write(x),n.update(k),n.update(A),n.update(k),await binFileUtils.endWriteSection(d),i&&i.info("Reading r1cs");let C=await binFileUtils.readSection(c,u,2);const L=new BigArray(f.nVars),R=new BigArray(f.nVars),z=new BigArray(f.nVars),T=new BigArray(f.nVars-b-1),P=new Array(b+1);i&&i.info("Reading tauG1");let $=await binFileUtils.readSection(r,o,12,(g-1)*w,g*w);i&&i.info("Reading tauG2");let j=await binFileUtils.readSection(r,o,13,(g-1)*p,g*p);i&&i.info("Reading alphatauG1");let I=await binFileUtils.readSection(r,o,14,(g-1)*w,g*w);i&&i.info("Reading betatauG1");let H=await binFileUtils.readSection(r,o,15,(g-1)*w,g*w);await async function(){const e=new Uint8Array(12+s.Fr.n8),a=new DataView(e.buffer),t=new Uint8Array(s.Fr.n8);s.Fr.toRprLE(t,0,s.Fr.e(1));let n=0;function r(){const e=C.slice(n,n+4);n+=4;return new DataView(e.buffer).getUint32(0,!0)}const o=new BigArray;for(let d=0;d<f.nConstraints;d++){i&&d%1e4==0&&i.debug(`processing constraints: ${d}/${f.nConstraints}`);const e=r();for(let i=0;i<e;i++){const e=r(),a=n;n+=s.Fr.n8;const t=0,i=w*d,l=3,c=w*d;"undefined"===typeof L[e]&&(L[e]=[]),L[e].push([t,i,a]),e<=b?("undefined"===typeof P[e]&&(P[e]=[]),P[e].push([l,c,a])):("undefined"===typeof T[e-b-1]&&(T[e-b-1]=[]),T[e-b-1].push([l,c,a])),o.push([0,d,e,a])}const a=r();for(let i=0;i<a;i++){const e=r(),a=n;n+=s.Fr.n8;const t=0,i=w*d,l=1,c=p*d,u=2,f=w*d;"undefined"===typeof R[e]&&(R[e]=[]),R[e].push([t,i,a]),"undefined"===typeof z[e]&&(z[e]=[]),z[e].push([l,c,a]),e<=b?("undefined"===typeof P[e]&&(P[e]=[]),P[e].push([u,f,a])):("undefined"===typeof T[e-b-1]&&(T[e-b-1]=[]),T[e-b-1].push([u,f,a])),o.push([1,d,e,a])}const t=r();for(let i=0;i<t;i++){const e=r(),a=n;n+=s.Fr.n8;const t=0,i=w*d;e<=b?("undefined"===typeof P[e]&&(P[e]=[]),P[e].push([t,i,a])):("undefined"===typeof T[e-b-1]&&(T[e-b-1]=[]),T[e-b-1].push([t,i,a]))}}for(let i=0;i<=b;i++){const e=0,a=w*(f.nConstraints+i),t=3,n=w*(f.nConstraints+i);"undefined"===typeof L[i]&&(L[i]=[]),L[i].push([e,a,-1]),"undefined"===typeof P[i]&&(P[i]=[]),P[i].push([t,n,-1]),o.push([0,f.nConstraints+i,i,-1])}await binFileUtils.startWriteSection(d,4);const l=new ffjavascript.BigBuffer(o.length*(12+s.Fr.n8)+4),c=new Uint8Array(4);new DataView(c.buffer).setUint32(0,o.length,!0),l.set(c);let u=4;for(let s=0;s<o.length;s++)i&&s%1e5==0&&i.debug(`writing coeffs: ${s}/${o.length}`),m(o[s]);function m(i){let n;a.setUint32(0,i[0],!0),a.setUint32(4,i[1],!0),a.setUint32(8,i[2],!0),n=i[3]>=0?s.Fr.fromRprLE(C.slice(i[3],i[3]+s.Fr.n8),0):s.Fr.fromRprLE(t,0);const r=s.Fr.mul(n,G);s.Fr.toRprLE(e,12,r),l.set(e,u),u+=e.length}await d.write(l),await binFileUtils.endWriteSection(d)}(),await q(3,"G1",P,"IC"),await async function(){await binFileUtils.startWriteSection(d,9);const e=new ffjavascript.BigBuffer(g*w);if(m<s.Fr.s){let a=await binFileUtils.readSection(r,o,12,(2*g-1)*w,2*g*w);for(let t=0;t<g;t++){i&&t%1e4==0&&i.debug(`spliting buffer: ${t}/${g}`);const n=a.slice((2*t+1)*w,(2*t+1)*w+w);e.set(n,t*w)}}else{if(m!=s.Fr.s)throw i&&i.error("Circuit too big"),new Error("Circuit too big for this curve");{const a=o[12][0].p+(2**(m+1)-1)*w;await r.readToBuffer(e,0,g*w,a+g*w)}}await d.write(e),await binFileUtils.endWriteSection(d)}(),await async function(){W(g-1);for(let e=0;e<g-1;e+=16384){i&&i.debug(`HashingHPoints: ${e}/${g}`);const a=Math.min(g-1,16384);await K(e,a)}}(),await q(8,"G1",T,"C"),await q(5,"G1",L,"A"),await q(6,"G1",R,"B1"),await q(7,"G2",z,"B2");const O=n.digest();return await binFileUtils.startWriteSection(d,10),await d.write(O),await d.writeULE32(0),await binFileUtils.endWriteSection(d),i&&i.info(formatHash(O,"Circuit hash: ")),await d.close(),await c.close(),await r.close(),O;async function q(e,a,t,r){const o=s[a];W(t.length),await binFileUtils.startWriteSection(d,e);let l=[],c=0;for(;c<t.length;){let e=0;for(;c<t.length&&e<s.tm.concurrency;){i&&i.debug(`Writing points start ${r}: ${c}/${t.length}`);let n=1,o=t[c]?t[c].length:0;for(;c+n<t.length&&o+(t[c+n]?t[c+n].length:0)<32768&&n<32768;)o+=t[c+n]?t[c+n].length:0,n++;const s=t.slice(c,c+n),u=c;l.push(M(a,s,i,r).then((e=>(i&&i.debug(`Writing points end ${r}: ${u}/${t.length}`),e)))),c+=n,e++}const u=await Promise.all(l);for(let a=0;a<u.length;a++){await d.write(u[a][0]);const e=await o.batchLEMtoU(u[a][0]);n.update(e)}l=[]}await binFileUtils.endWriteSection(d)}async function M(e,a,t,i){const n=s[e],r=2*n.F.n8,o=3*n.F.n8,l=2*n.F.n8;let c,u,f,d;if("G1"==e)c="g1m_timesScalarAffine",u="g1m_multiexpAffine",f="g1m_batchToAffine",d="g1m_zero";else{if("G2"!=e)throw new Error("Invalid group");c="g2m_timesScalarAffine",u="g2m_multiexpAffine",f="g2m_batchToAffine",d="g2m_zero"}let w,p,m=0;for(let s=0;s<a.length;s++)m+=a[s]?a[s].length:0;m>32768?(w=new ffjavascript.BigBuffer(m*r),p=new ffjavascript.BigBuffer(m*s.Fr.n8)):(w=new Uint8Array(m*r),p=new Uint8Array(m*s.Fr.n8));let b=0,g=0;const h=[$,j,I,H],_=new Uint8Array(s.Fr.n8);s.Fr.toRprLE(_,0,s.Fr.e(1));let y=0;for(let F=0;F<a.length;F++)if(a[F])for(let e=0;e<a[F].length;e++)t&&e&&e%1e4==0&&t.debug(`Configuring big array ${i}: ${e}/${a[F].length}`),w.set(h[a[F][e][0]].slice(a[F][e][1],a[F][e][1]+r),y*r),a[F][e][2]>=0?p.set(C.slice(a[F][e][2],a[F][e][2]+s.Fr.n8),y*s.Fr.n8):p.set(_,y*s.Fr.n8),y++;if(a.length>1){const e=[];e.push({cmd:"ALLOCSET",var:0,buff:w}),e.push({cmd:"ALLOCSET",var:1,buff:p}),e.push({cmd:"ALLOC",var:2,len:a.length*o}),b=0,g=0;let t=0;for(let i=0;i<a.length;i++)a[i]?(1==a[i].length?e.push({cmd:"CALL",fnName:c,params:[{var:0,offset:b},{var:1,offset:g},{val:s.Fr.n8},{var:2,offset:t}]}):e.push({cmd:"CALL",fnName:u,params:[{var:0,offset:b},{var:1,offset:g},{val:s.Fr.n8},{val:a[i].length},{var:2,offset:t}]}),b+=r*a[i].length,g+=s.Fr.n8*a[i].length,t+=o):(e.push({cmd:"CALL",fnName:d,params:[{var:2,offset:t}]}),t+=o);e.push({cmd:"CALL",fnName:f,params:[{var:2},{val:a.length},{var:2}]}),e.push({cmd:"GET",out:0,var:2,len:a.length*l});return await s.tm.queueAction(e)}{let e=await n.multiExpAffine(w,p,t,i);return e=[n.toAffine(e)],e}}async function K(e,a){const t=await r.read(a*w,o[2][0].p+(e+g)*w),i=await r.read(a*w,o[2][0].p+e*w),l=s.tm.concurrency,c=Math.floor(a/l),u=[];for(let n=0;n<l;n++){let e;if(e=n<l-1?c:a-n*c,0==e)continue;const r=t.slice(n*c*w,(n*c+e)*w),o=i.slice(n*c*w,(n*c+e)*w);u.push(V(r,o))}const f=await Promise.all(u);for(let r=0;r<f.length;r++)n.update(f[r][0])}async function V(e,a){const t=e.byteLength/w,i=3*s.G1.F.n8,n=[];n.push({cmd:"ALLOCSET",var:0,buff:e}),n.push({cmd:"ALLOCSET",var:1,buff:a}),n.push({cmd:"ALLOC",var:2,len:t*i});for(let r=0;r<t;r++)n.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:r*w},{var:1,offset:r*w},{var:2,offset:r*i}]});n.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:t},{var:2}]}),n.push({cmd:"CALL",fnName:"g1m_batchLEMtoU",params:[{var:2},{val:t},{var:2}]}),n.push({cmd:"GET",out:0,var:2,len:t*w});return await s.tm.queueAction(n)}function W(e){const a=new Uint8Array(4);new DataView(a.buffer,a.byteOffset,a.byteLength).setUint32(0,e,!1),n.update(a)}}async function phase2exportMPCParams(e,a,t){const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(e,"zkey",2),r=await readHeader$1(i,n);if("groth16"!=r.protocol)throw new Error("zkey file is not groth16");const o=await getCurveFromQ(r.q),s=2*o.G1.F.n8,l=2*o.G2.F.n8,c=await readMPCParams(i,o,n),u=await fastFile__namespace.createOverride(a);let f;await h(r.vk_alpha_1),await h(r.vk_beta_1),await _(r.vk_beta_2),await _(r.vk_gamma_2),await h(r.vk_delta_1),await _(r.vk_delta_2),f=await binFileUtils__namespace.readSection(i,n,3),f=await o.G1.batchLEMtoU(f),await y("G1",f);const d=await binFileUtils__namespace.readSection(i,n,9);let w,p,m,b,g;w=await o.G1.fft(d,"affine","jacobian",t),w=await o.G1.batchApplyKey(w,o.Fr.neg(o.Fr.e(2)),o.Fr.w[r.power+1],"jacobian","affine",t),w=w.slice(0,w.byteLength-s),w=await o.G1.batchLEMtoU(w),await y("G1",w),p=await binFileUtils__namespace.readSection(i,n,8),p=await o.G1.batchLEMtoU(p),await y("G1",p),m=await binFileUtils__namespace.readSection(i,n,5),m=await o.G1.batchLEMtoU(m),await y("G1",m),b=await binFileUtils__namespace.readSection(i,n,6),b=await o.G1.batchLEMtoU(b),await y("G1",b),g=await binFileUtils__namespace.readSection(i,n,7),g=await o.G2.batchLEMtoU(g),await y("G2",g),await u.write(c.csHash),await async function(e){const a=new Uint8Array(4);new DataView(a.buffer,a.byteOffset,a.byteLength).setUint32(0,e,!1),await u.write(a)}(c.contributions.length);for(let F=0;F<c.contributions.length;F++){const e=c.contributions[F];await h(e.deltaAfter),await h(e.delta.g1_s),await h(e.delta.g1_sx),await _(e.delta.g2_spx),await u.write(e.transcript)}async function h(e){const a=new Uint8Array(s);o.G1.toRprUncompressed(a,0,e),await u.write(a)}async function _(e){const a=new Uint8Array(l);o.G2.toRprUncompressed(a,0,e),await u.write(a)}async function y(e,a){let t;t="G1"==e?s:l;const i=new Uint8Array(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint32(0,a.byteLength/t,!1),await u.write(i),await u.write(a)}await i.close(),await u.close()}async function phase2importMPCParams(e,a,t,i,n){const{fd:r,sections:o}=await binFileUtils__namespace.readBinFile(e,"zkey",2),s=await readHeader$1(r,o,!1);if("groth16"!=s.protocol)throw new Error("zkey file is not groth16");const l=await getCurveFromQ(s.q),c=2*l.G1.F.n8,u=2*l.G2.F.n8,f=await readMPCParams(r,l,o),d={},w=await fastFile__namespace.readExisting(a);w.pos=3*c+3*u+8+c*s.nVars+4+c*(s.domainSize-1)+4+c*s.nVars+4+c*s.nVars+4+u*s.nVars,d.csHash=await w.read(64);const p=await w.readUBE32();d.contributions=[];for(let S=0;S<p;S++){const e={delta:{}};e.deltaAfter=await v(w),e.delta.g1_s=await v(w),e.delta.g1_sx=await v(w),e.delta.g2_spx=await G(w),e.transcript=await w.read(64),S<f.contributions.length&&(e.type=f.contributions[S].type,1==e.type&&(e.beaconHash=f.contributions[S].beaconHash,e.numIterationsExp=f.contributions[S].numIterationsExp),f.contributions[S].name&&(e.name=f.contributions[S].name)),d.contributions.push(e)}if(!hashIsEqual(d.csHash,f.csHash))return n&&n.error("Hash of the original circuit does not match with the MPC one"),!1;if(f.contributions.length>d.contributions.length)return n&&n.error("The impoerted file does not include new contributions"),!1;for(let S=0;S<f.contributions.length;S++)if(!U(f.contributions[S],d.contributions[S]))return n&&n.error(`Previos contribution ${S} does not match`),!1;if(i)for(let S=f.contributions.length;S<d.contributions.length;S++)d.contributions[S].name=i;const m=await binFileUtils__namespace.createBinFile(t,"zkey",1,10);w.pos=0,w.pos+=c,w.pos+=c,w.pos+=u,w.pos+=u,s.vk_delta_1=await v(w),s.vk_delta_2=await G(w),await writeHeader(m,s);if(await w.readUBE32()!=s.nPublic+1)return n&&n.error("Invalid number of points in IC"),await m.discard(),!1;w.pos+=c*(s.nPublic+1),await binFileUtils__namespace.copySection(r,o,m,3),await binFileUtils__namespace.copySection(r,o,m,4);if(await w.readUBE32()!=s.domainSize-1)return n&&n.error("Invalid number of points in H"),await m.discard(),!1;let b;const g=await w.read(c*(s.domainSize-1)),h=await l.G1.batchUtoLEM(g);b=new Uint8Array(s.domainSize*c),b.set(h),l.G1.toRprLEM(b,c*(s.domainSize-1),l.G1.zeroAffine);const _=l.Fr.neg(l.Fr.inv(l.Fr.e(2))),y=l.Fr.inv(l.Fr.w[s.power+1]);b=await l.G1.batchApplyKey(b,_,y,"affine","jacobian",n),b=await l.G1.ifft(b,"jacobian","affine",n),await binFileUtils__namespace.startWriteSection(m,9),await m.write(b),await binFileUtils__namespace.endWriteSection(m);if(await w.readUBE32()!=s.nVars-s.nPublic-1)return n&&n.error("Invalid number of points in L"),await m.discard(),!1;let F;F=await w.read(c*(s.nVars-s.nPublic-1)),F=await l.G1.batchUtoLEM(F),await binFileUtils__namespace.startWriteSection(m,8),await m.write(F),await binFileUtils__namespace.endWriteSection(m);if(await w.readUBE32()!=s.nVars)return n&&n.error("Invalid number of points in A"),await m.discard(),!1;w.pos+=c*s.nVars,await binFileUtils__namespace.copySection(r,o,m,5);if(await w.readUBE32()!=s.nVars)return n&&n.error("Invalid number of points in B1"),await m.discard(),!1;w.pos+=c*s.nVars,await binFileUtils__namespace.copySection(r,o,m,6);return await w.readUBE32()!=s.nVars?(n&&n.error("Invalid number of points in B2"),await m.discard(),!1):(w.pos+=u*s.nVars,await binFileUtils__namespace.copySection(r,o,m,7),await writeMPCParams(m,l,d),await w.close(),await m.close(),await r.close(),!0);async function v(e){const a=await e.read(2*l.G1.F.n8);return l.G1.fromRprUncompressed(a,0)}async function G(e){const a=await e.read(2*l.G2.F.n8);return l.G2.fromRprUncompressed(a,0)}function U(e,a){return!!l.G1.eq(e.deltaAfter,a.deltaAfter)&&(!!l.G1.eq(e.delta.g1_s,a.delta.g1_s)&&(!!l.G1.eq(e.delta.g1_sx,a.delta.g1_sx)&&(!!l.G2.eq(e.delta.g2_spx,a.delta.g2_spx)&&!!hashIsEqual(e.transcript,a.transcript))))}}const sameRatio=sameRatio$2;async function phase2verifyFromInit(e,a,t,i){let n;await Blake2b__default.default.ready();const{fd:r,sections:o}=await binFileUtils__namespace.readBinFile(t,"zkey",2),s=await readHeader$1(r,o,!1);if("groth16"!=s.protocol)throw new Error("zkey file is not groth16");const l=await getCurveFromQ(s.q),c=2*l.G1.F.n8,u=await readMPCParams(r,l,o),f=Blake2b__default.default(64);f.update(u.csHash);let d=l.G1.g;for(let y=0;y<u.contributions.length;y++){const e=u.contributions[y],a=cloneHasher(f);if(hashG1(a,l,e.delta.g1_s),hashG1(a,l,e.delta.g1_sx),!hashIsEqual(a.digest(),e.transcript))return console.log(`INVALID(${y}): Inconsistent transcript `),!1;const t=hashToG2(l,e.transcript);if(n=await sameRatio(l,e.delta.g1_s,e.delta.g1_sx,t,e.delta.g2_spx),!0!==n)return console.log(`INVALID(${y}): public key G1 and G2 do not have the same ration `),!1;if(n=await sameRatio(l,d,e.deltaAfter,t,e.delta.g2_spx),!0!==n)return console.log(`INVALID(${y}): deltaAfter does not fillow the public key `),!1;if(1==e.type){const a=rngFromBeaconParams(e.beaconHash,e.numIterationsExp),t=l.Fr.fromRng(a),i=l.G1.toAffine(l.G1.fromRng(a)),n=l.G1.toAffine(l.G1.timesFr(i,t));if(!0!==l.G1.eq(i,e.delta.g1_s))return console.log(`INVALID(${y}): Key of the beacon does not match. g1_s `),!1;if(!0!==l.G1.eq(n,e.delta.g1_sx))return console.log(`INVALID(${y}): Key of the beacon does not match. g1_sx `),!1}hashPubKey(f,l,e);const i=Blake2b__default.default(64);hashPubKey(i,l,e),e.contributionHash=i.digest(),d=e.deltaAfter}const{fd:w,sections:p}=await binFileUtils__namespace.readBinFile(e,"zkey",2),m=await readHeader$1(w,p,!1);if("groth16"!=m.protocol)throw new Error("zkeyinit file is not groth16");if(!ffjavascript.Scalar.eq(m.q,s.q)||!ffjavascript.Scalar.eq(m.r,s.r)||m.n8q!=s.n8q||m.n8r!=s.n8r)return i&&i.error("INVALID:  Different curves"),!1;if(m.nVars!=s.nVars||m.nPublic!=s.nPublic||m.domainSize!=s.domainSize)return i&&i.error("INVALID:  Different circuit parameters"),!1;if(!l.G1.eq(s.vk_alpha_1,m.vk_alpha_1))return i&&i.error("INVALID:  Invalid alpha1"),!1;if(!l.G1.eq(s.vk_beta_1,m.vk_beta_1))return i&&i.error("INVALID:  Invalid beta1"),!1;if(!l.G2.eq(s.vk_beta_2,m.vk_beta_2))return i&&i.error("INVALID:  Invalid beta2"),!1;if(!l.G2.eq(s.vk_gamma_2,m.vk_gamma_2))return i&&i.error("INVALID:  Invalid gamma2"),!1;if(!l.G1.eq(s.vk_delta_1,d))return i&&i.error("INVALID:  Invalid delta1"),!1;if(n=await sameRatio(l,l.G1.g,d,l.G2.g,s.vk_delta_2),!0!==n)return i&&i.error("INVALID:  Invalid delta2"),!1;const b=await readMPCParams(w,l,p);if(!hashIsEqual(u.csHash,b.csHash))return i&&i.error("INVALID:  Circuit does not match"),!1;if(o[8][0].size!=c*(s.nVars-s.nPublic-1))return i&&i.error("INVALID:  Invalid L section size"),!1;if(o[9][0].size!=c*s.domainSize)return i&&i.error("INVALID:  Invalid H section size"),!1;let g;if(g=await binFileUtils__namespace.sectionIsEqual(r,o,w,p,3),!g)return i&&i.error("INVALID:  IC section is not identical"),!1;if(g=await binFileUtils__namespace.sectionIsEqual(r,o,w,p,4),!g)return i&&i.error("Coeffs section is not identical"),!1;if(g=await binFileUtils__namespace.sectionIsEqual(r,o,w,p,5),!g)return i&&i.error("A section is not identical"),!1;if(g=await binFileUtils__namespace.sectionIsEqual(r,o,w,p,6),!g)return i&&i.error("B1 section is not identical"),!1;if(g=await binFileUtils__namespace.sectionIsEqual(r,o,w,p,7),!g)return i&&i.error("B2 section is not identical"),!1;if(n=await async function(e,a,t,r,o,s,c,u,f){const d=1<<20,w=l[e],p=2*w.F.n8;await binFileUtils__namespace.startReadUniqueSection(a,t,s),await binFileUtils__namespace.startReadUniqueSection(r,o,s);let m=w.zero,b=w.zero;const g=t[s][0].size/p;for(let n=0;n<g;n+=d){i&&i.debug(`Same ratio check ${f}:  ${n}/${g}`);const e=Math.min(g-n,d),t=await a.read(e*p),o=await r.read(e*p),s=new Uint8Array(4*e);crypto__default.default.randomFillSync(s);const l=await w.multiExpAffine(t,s),c=await w.multiExpAffine(o,s);m=w.add(m,l),b=w.add(b,c)}return await binFileUtils__namespace.endReadSection(a),await binFileUtils__namespace.endReadSection(r),0==g||(n=await sameRatio(l,m,b,c,u),!0===n)}("G1",w,p,r,o,8,s.vk_delta_2,m.vk_delta_2,"L section"),!0!==n)return i&&i.error("L section does not match"),!1;if(n=await async function(){const e=1<<20,t=l.G1,c=l.Fr,u=2*t.F.n8,{fd:f,sections:d}=await binFileUtils__namespace.readBinFile(a,"ptau",1);let w=new ffjavascript.BigBuffer(s.domainSize*s.n8r);const p=new Array(8);for(let a=0;a<8;a++)p[a]=crypto__default.default.randomBytes(4).readUInt32BE(0,!0);const b=new ffjavascript.ChaCha(p);for(let a=0;a<s.domainSize-1;a++){const e=c.fromRng(b);c.toRprLE(w,a*s.n8r,e)}c.toRprLE(w,(s.domainSize-1)*s.n8r,c.zero);let g,_=t.zero;for(let a=0;a<s.domainSize;a+=e){i&&i.debug(`H Verificaition(tau):  ${a}/${s.domainSize}`);const n=Math.min(s.domainSize-a,e),r=await f.read(u*n,d[2][0].p+s.domainSize*u+a*u),o=await f.read(u*n,d[2][0].p+a*u),l=await h(r,o),c=w.slice(a*s.n8r,(a+n)*s.n8r),p=await t.multiExpAffine(l,c);_=t.add(_,p)}if(w=await c.batchToMontgomery(w),s.power<c.s)g=c.neg(c.e(2));else{const e=2**c.s,a=c.exp(c.shift,e);g=c.sub(a,c.one)}const y=s.power<c.s?c.w[s.power+1]:c.shift;w=await c.batchApplyKey(w,g,y),w=await c.fft(w),w=await c.batchFromMontgomery(w),await binFileUtils__namespace.startReadUniqueSection(r,o,9);let F=t.zero;for(let a=0;a<s.domainSize;a+=e){i&&i.debug(`H Verificaition(lagrange):  ${a}/${s.domainSize}`);const n=Math.min(s.domainSize-a,e),o=await r.read(u*n),l=w.slice(a*s.n8r,(a+n)*s.n8r),c=await t.multiExpAffine(o,l);F=t.add(F,c)}return await binFileUtils__namespace.endReadSection(r),n=await sameRatio(l,_,F,s.vk_delta_2,m.vk_delta_2),!0===n}(),!0!==n)return i&&i.error("H section does not match"),!1;i&&i.info(formatHash(u.csHash,"Circuit Hash: ")),await r.close(),await w.close();for(let y=u.contributions.length-1;y>=0;y--){const e=u.contributions[y];i&&i.info("-------------------------"),i&&i.info(formatHash(e.contributionHash,`contribution #${y+1} ${e.name?e.name:""}:`)),1==e.type&&(i&&i.info(`Beacon generator: ${byteArray2hex(e.beaconHash)}`),i&&i.info(`Beacon iterations Exp: ${e.numIterationsExp}`))}return i&&i.info("-------------------------"),i&&i.info("ZKey Ok!"),!0;async function h(e,a){const t=2*l.G1.F.n8,i=e.byteLength/t,n=l.tm.concurrency,r=Math.floor(i/n),o=[];for(let l=0;l<n;l++){let t;if(t=l<n-1?r:i-l*r,0==t)continue;const s=e.slice(l*r*c,(l*r+t)*c),u=a.slice(l*r*c,(l*r+t)*c);o.push(_(s,u))}const s=await Promise.all(o),u=new Uint8Array(i*t);let f=0;for(let l=0;l<s.length;l++)u.set(s[l][0],f),f+=s[l][0].byteLength;return u}async function _(e,a){const t=2*l.G1.F.n8,i=3*l.G1.F.n8,n=e.byteLength/t,r=[];r.push({cmd:"ALLOCSET",var:0,buff:e}),r.push({cmd:"ALLOCSET",var:1,buff:a}),r.push({cmd:"ALLOC",var:2,len:n*i});for(let o=0;o<n;o++)r.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:o*t},{var:1,offset:o*t},{var:2,offset:o*i}]});r.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:n},{var:2}]}),r.push({cmd:"GET",out:0,var:2,len:n*t});return await l.tm.queueAction(r)}}async function phase2verifyFromR1cs(e,a,t,i){const n={type:"bigMem"};return await newZKey(e,a,n,i),await phase2verifyFromInit(n,a,t,i)}async function phase2contribute(e,a,t,i,n){await Blake2b__default.default.ready();const{fd:r,sections:o}=await binFileUtils__namespace.readBinFile(e,"zkey",2),s=await readHeader$1(r,o);if("groth16"!=s.protocol)throw new Error("zkey file is not groth16");const l=await getCurveFromQ(s.q),c=await readMPCParams(r,l,o),u=await binFileUtils__namespace.createBinFile(a,"zkey",1,10),f=await getRandomRng(i),d=Blake2b__default.default(64);d.update(c.csHash);for(let g=0;g<c.contributions.length;g++)hashPubKey(d,l,c.contributions[g]);const w={delta:{}};w.delta.prvKey=l.Fr.fromRng(f),w.delta.g1_s=l.G1.toAffine(l.G1.fromRng(f)),w.delta.g1_sx=l.G1.toAffine(l.G1.timesFr(w.delta.g1_s,w.delta.prvKey)),hashG1(d,l,w.delta.g1_s),hashG1(d,l,w.delta.g1_sx),w.transcript=d.digest(),w.delta.g2_sp=hashToG2(l,w.transcript),w.delta.g2_spx=l.G2.toAffine(l.G2.timesFr(w.delta.g2_sp,w.delta.prvKey)),s.vk_delta_1=l.G1.timesFr(s.vk_delta_1,w.delta.prvKey),s.vk_delta_2=l.G2.timesFr(s.vk_delta_2,w.delta.prvKey),w.deltaAfter=s.vk_delta_1,w.type=0,t&&(w.name=t),c.contributions.push(w),await writeHeader(u,s),await binFileUtils__namespace.copySection(r,o,u,3),await binFileUtils__namespace.copySection(r,o,u,4),await binFileUtils__namespace.copySection(r,o,u,5),await binFileUtils__namespace.copySection(r,o,u,6),await binFileUtils__namespace.copySection(r,o,u,7);const p=l.Fr.inv(w.delta.prvKey);await applyKeyToSection(r,o,u,8,l,"G1",p,l.Fr.e(1),"L Section",n),await applyKeyToSection(r,o,u,9,l,"G1",p,l.Fr.e(1),"H Section",n),await writeMPCParams(u,l,c),await r.close(),await u.close();const m=Blake2b__default.default(64);hashPubKey(m,l,w);const b=m.digest();return n&&n.info(formatHash(c.csHash,"Circuit Hash: ")),n&&n.info(formatHash(b,"Contribution Hash: ")),b}async function beacon(e,a,t,i,n,r){await Blake2b__default.default.ready();const o=hex2ByteArray(i);if(0==o.byteLength||2*o.byteLength!=i.length)return r&&r.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(o.length>=256)return r&&r.error("Maximum lenght of beacon hash is 255 bytes"),!1;if((n=parseInt(n))<10||n>63)return r&&r.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;const{fd:s,sections:l}=await binFileUtils__namespace.readBinFile(e,"zkey",2),c=await readHeader$1(s,l);if("groth16"!=c.protocol)throw new Error("zkey file is not groth16");const u=await getCurveFromQ(c.q),f=await readMPCParams(s,u,l),d=await binFileUtils__namespace.createBinFile(a,"zkey",1,10),w=await rngFromBeaconParams(o,n),p=Blake2b__default.default(64);p.update(f.csHash);for(let _=0;_<f.contributions.length;_++)hashPubKey(p,u,f.contributions[_]);const m={delta:{}};m.delta.prvKey=u.Fr.fromRng(w),m.delta.g1_s=u.G1.toAffine(u.G1.fromRng(w)),m.delta.g1_sx=u.G1.toAffine(u.G1.timesFr(m.delta.g1_s,m.delta.prvKey)),hashG1(p,u,m.delta.g1_s),hashG1(p,u,m.delta.g1_sx),m.transcript=p.digest(),m.delta.g2_sp=hashToG2(u,m.transcript),m.delta.g2_spx=u.G2.toAffine(u.G2.timesFr(m.delta.g2_sp,m.delta.prvKey)),c.vk_delta_1=u.G1.timesFr(c.vk_delta_1,m.delta.prvKey),c.vk_delta_2=u.G2.timesFr(c.vk_delta_2,m.delta.prvKey),m.deltaAfter=c.vk_delta_1,m.type=1,m.numIterationsExp=n,m.beaconHash=o,t&&(m.name=t),f.contributions.push(m),await writeHeader(d,c),await binFileUtils__namespace.copySection(s,l,d,3),await binFileUtils__namespace.copySection(s,l,d,4),await binFileUtils__namespace.copySection(s,l,d,5),await binFileUtils__namespace.copySection(s,l,d,6),await binFileUtils__namespace.copySection(s,l,d,7);const b=u.Fr.inv(m.delta.prvKey);await applyKeyToSection(s,l,d,8,u,"G1",b,u.Fr.e(1),"L Section",r),await applyKeyToSection(s,l,d,9,u,"G1",b,u.Fr.e(1),"H Section",r),await writeMPCParams(d,u,f),await s.close(),await d.close();const g=Blake2b__default.default(64);hashPubKey(g,u,m);const h=g.digest();return r&&r.info(formatHash(h,"Contribution Hash: ")),h}async function zkeyExportJson(e){return await readZKey(e,!0)}async function bellmanContribute(e,a,t,i,n){await Blake2b__default.default.ready();const r=await getRandomRng(i),o=e.Fr.fromRng(r),s=e.Fr.inv(o),l=2*e.G1.F.n8,c=2*e.G2.F.n8,u=await fastFile__namespace.readExisting(a),f=await fastFile__namespace.createOverride(t);await x(l),await x(l),await x(c),await x(c);const d=await A(),w=e.G1.timesFr(d,o);await C(w);const p=await k(),m=e.G2.timesFr(p,o);await L(m);const b=await u.readUBE32();await f.writeUBE32(b),await x(b*l);const g=await u.readUBE32();await f.writeUBE32(g),await applyKeyToChallengeSection(u,f,null,e,"G1",g,s,e.Fr.e(1),"UNCOMPRESSED","H",n);const h=await u.readUBE32();await f.writeUBE32(h),await applyKeyToChallengeSection(u,f,null,e,"G1",h,s,e.Fr.e(1),"UNCOMPRESSED","L",n);const _=await u.readUBE32();await f.writeUBE32(_),await x(_*l);const y=await u.readUBE32();await f.writeUBE32(y),await x(y*l);const F=await u.readUBE32();await f.writeUBE32(F),await x(F*c);const v=Blake2b__default.default(64),G={};G.csHash=await u.read(64),v.update(G.csHash);const U=await u.readUBE32();G.contributions=[];for(let R=0;R<U;R++){const a={delta:{}};a.deltaAfter=await A(),a.delta.g1_s=await A(),a.delta.g1_sx=await A(),a.delta.g2_spx=await k(),a.transcript=await u.read(64),G.contributions.push(a),hashPubKey(v,e,a)}const S={delta:{}};S.delta.prvKey=o,S.delta.g1_s=e.G1.toAffine(e.G1.fromRng(r)),S.delta.g1_sx=e.G1.toAffine(e.G1.timesFr(S.delta.g1_s,o)),hashG1(v,e,S.delta.g1_s),hashG1(v,e,S.delta.g1_sx),S.transcript=v.digest(),S.delta.g2_sp=hashToG2(e,S.transcript),S.delta.g2_spx=e.G2.toAffine(e.G2.timesFr(S.delta.g2_sp,o)),S.deltaAfter=w,S.type=0,G.contributions.push(S),await f.write(G.csHash),await f.writeUBE32(G.contributions.length);for(let R=0;R<G.contributions.length;R++){const e=G.contributions[R];await C(e.deltaAfter),await C(e.delta.g1_s),await C(e.delta.g1_sx),await L(e.delta.g2_spx),await f.write(e.transcript)}const B=Blake2b__default.default(64);hashPubKey(B,e,S);const E=B.digest();return n&&n.info(formatHash(E,"Contribution Hash: ")),await f.close(),await u.close(),E;async function x(e){const a=2*u.pageSize;for(let t=0;t<e;t+=a){const i=Math.min(e-t,a),n=await u.read(i);await f.write(n)}}async function A(){const a=await u.read(2*e.G1.F.n8);return e.G1.fromRprUncompressed(a,0)}async function k(){const a=await u.read(2*e.G2.F.n8);return e.G2.fromRprUncompressed(a,0)}async function C(a){const t=new Uint8Array(l);e.G1.toRprUncompressed(t,0,a),await f.write(t)}async function L(a){const t=new Uint8Array(c);e.G2.toRprUncompressed(t,0,a),await f.write(t)}}const{stringifyBigInts:stringifyBigInts$1}=ffjavascript.utils;async function zkeyExportVerificationKey(e){const{fd:a,sections:t}=await binFileUtils__namespace.readBinFile(e,"zkey",2),i=await readHeader$1(a,t);let n;if("groth16"==i.protocol)n=await groth16Vk(i,a,t);else{if("plonk"!=i.protocol)throw new Error("zkey file is not groth16");n=await plonkVk(i)}return await a.close(),n}async function groth16Vk(e,a,t){const i=await getCurveFromQ(e.q),n=2*i.G1.F.n8,r=await i.pairing(e.vk_alpha_1,e.vk_beta_2);let o={protocol:e.protocol,curve:i.name,nPublic:e.nPublic,vk_alpha_1:i.G1.toObject(e.vk_alpha_1),vk_beta_2:i.G2.toObject(e.vk_beta_2),vk_gamma_2:i.G2.toObject(e.vk_gamma_2),vk_delta_2:i.G2.toObject(e.vk_delta_2),vk_alphabeta_12:i.Gt.toObject(r)};await binFileUtils__namespace.startReadUniqueSection(a,t,3),o.IC=[];for(let s=0;s<=e.nPublic;s++){const e=await a.read(n),t=i.G1.toObject(e);o.IC.push(t)}return await binFileUtils__namespace.endReadSection(a),o=stringifyBigInts$1(o),o}async function plonkVk(e){const a=await getCurveFromQ(e.q);let t={protocol:e.protocol,curve:a.name,nPublic:e.nPublic,power:e.power,k1:a.Fr.toObject(e.k1),k2:a.Fr.toObject(e.k2),Qm:a.G1.toObject(e.Qm),Ql:a.G1.toObject(e.Ql),Qr:a.G1.toObject(e.Qr),Qo:a.G1.toObject(e.Qo),Qc:a.G1.toObject(e.Qc),S1:a.G1.toObject(e.S1),S2:a.G1.toObject(e.S2),S3:a.G1.toObject(e.S3),X_2:a.G2.toObject(e.X_2),w:a.Fr.toObject(a.Fr.w[e.power])};return t=stringifyBigInts$1(t),t}async function exportSolidityVerifier(e,a,t){const i=await zkeyExportVerificationKey(e);let n=a[i.protocol];return ejs__default.default.render(n,i)}var zkey=Object.freeze({__proto__:null,newZKey:newZKey,exportBellman:phase2exportMPCParams,importBellman:phase2importMPCParams,verifyFromR1cs:phase2verifyFromR1cs,verifyFromInit:phase2verifyFromInit,contribute:phase2contribute,beacon:beacon,exportJson:zkeyExportJson,bellmanContribute:bellmanContribute,exportVerificationKey:zkeyExportVerificationKey,exportSolidityVerifier:exportSolidityVerifier});async function plonkSetup(e,a,t,i){globalThis.gc&&globalThis.gc(),await Blake2b__default.default.ready();const{fd:n,sections:r}=await binFileUtils.readBinFile(a,"ptau",1,1<<22,1<<24),{curve:o,power:s}=await readPTauHeader(n,r),{fd:l,sections:c}=await binFileUtils.readBinFile(e,"r1cs",1,1<<22,1<<24),u=await r1csfile.readR1csHeader(l,c,!1),f=2*o.G1.F.n8,d=o.G1,w=2*o.G2.F.n8,p=o.Fr,m=o.Fr.n8;i&&i.info("Reading r1cs");let b=await binFileUtils.readSection(l,c,2);const g=new BigArray,h=new BigArray;let _=u.nVars;const y=u.nOutputs+u.nPubInputs;await async function(){let e=0;function a(){const a=b.slice(e,e+4);e+=4;return new DataView(a.buffer).getUint32(0,!0)}function t(){const a=p.fromRprLE(b.slice(e,e+o.Fr.n8));return e+=o.Fr.n8,a}function n(){const e=[],i={k:o.Fr.zero},n=a();for(let r=0;r<n;r++){const n=a(),r=t();0==n?i.k=r:e.push([n,r])}const s=r(e);return i.s=s[0],i.coef=s[1],i}function r(e){if(0==e.length)return[0,o.Fr.zero];if(1==e.length)return e[0];const a=e.slice(0,e.length>>1),t=e.slice(e.length>>1),i=r(a),n=r(t),s=i[0],l=n[0],c=_++,u=o.Fr.zero,f=p.neg(i[1]),d=p.neg(n[1]),w=o.Fr.one,m=o.Fr.zero;return g.push([s,l,c,u,f,d,w,m]),h.push([s,l,i[1],n[1]]),[c,o.Fr.one]}for(let i=1;i<=y;i++){const e=i,a=0,t=0,n=o.Fr.zero,r=o.Fr.one,s=o.Fr.zero,l=o.Fr.zero,c=o.Fr.zero;g.push([e,a,t,n,r,s,l,c])}for(let s=0;s<u.nConstraints;s++){i&&s%1e4==0&&i.debug(`processing constraints: ${s}/${u.nConstraints}`);const e=n(),a=n(),t=n(),r=e.s,l=a.s,c=t.s,f=o.Fr.mul(e.coef,a.coef),d=o.Fr.mul(e.coef,a.k),w=o.Fr.mul(e.k,a.coef),p=o.Fr.neg(t.coef),m=o.Fr.sub(o.Fr.mul(e.k,a.k),t.k);g.push([r,l,c,f,d,w,p,m])}}(),globalThis.gc&&globalThis.gc();const F=await binFileUtils.createBinFile(t,"zkey",1,14,1<<22,1<<24);if(u.prime!=o.r)return i&&i.error("r1cs curve does not match powers of tau ceremony curve"),-1;let v=log2(g.length-1)+1;v<3&&(v=3);const G=2**v;if(i&&i.info("Plonk constraints: "+g.length),v>s)return i&&i.error(`circuit too big for this power of tau ceremony. ${g.length} > 2**${s}`),-1;if(!r[12])return i&&i.error("Powers of tau is not prepared."),-1;const U=new ffjavascript.BigBuffer(G*f),S=r[12][0].p+(2**v-1)*f;await n.readToBuffer(U,0,G*f,S);const[B,E]=function(){let e=p.two;for(;t(e,[],v);)p.add(e,p.one);let a=p.add(e,p.one);for(;t(a,[e],v);)p.add(a,p.one);return[e,a];function t(e,a,t){const i=2**t;let n=p.one;for(let r=0;r<i;r++){if(p.eq(e,n))return!0;for(let t=0;t<a.length;t++)if(p.eq(e,p.mul(a[t],n)))return!0;n=p.mul(n,p.w[t])}return!1}}(),x={};await async function(e,a){await binFileUtils.startWriteSection(F,e);const t=new Uint8Array(8+2*m),n=new DataView(t.buffer);for(let r=0;r<h.length;r++){const e=h[r];let o=0;n.setUint32(o,e[0],!0),o+=4,n.setUint32(o,e[1],!0),o+=4,t.set(e[2],o),o+=m,t.set(e[3],o),o+=m,await F.write(t),i&&r%1e6==0&&i.debug(`writing ${a}: ${r}/${h.length}`)}await binFileUtils.endWriteSection(F)}(3,"Additions"),globalThis.gc&&globalThis.gc(),await k(4,0,"Amap"),globalThis.gc&&globalThis.gc(),await k(5,1,"Bmap"),globalThis.gc&&globalThis.gc(),await k(6,2,"Cmap"),globalThis.gc&&globalThis.gc(),await C(7,3,"Qm"),globalThis.gc&&globalThis.gc(),await C(8,4,"Ql"),globalThis.gc&&globalThis.gc(),await C(9,5,"Qr"),globalThis.gc&&globalThis.gc(),await C(10,6,"Qo"),globalThis.gc&&globalThis.gc(),await C(11,7,"Qc"),globalThis.gc&&globalThis.gc(),await async function(e,a){const t=new ffjavascript.BigBuffer(m*G*3),n=new BigArray(_),r=new BigArray(_);let s=p.one;for(let o=0;o<G;o++)o<g.length?(f(g[o][0],o),f(g[o][1],G+o),f(g[o][2],2*G+o)):(f(0,o),f(0,G+o),f(0,2*G+o)),s=p.mul(s,p.w[v]),i&&o%1e6==0&&i.debug(`writing ${a} phase1: ${o}/${g.length}`);for(let o=0;o<_;o++)"undefined"!==typeof r[o]?t.set(n[o],r[o]*m):console.log("Variable not used"),i&&o%1e6==0&&i.debug(`writing ${a} phase2: ${o}/${_}`);globalThis.gc&&globalThis.gc();await binFileUtils.startWriteSection(F,e);let l=t.slice(0,G*m);await L(l),globalThis.gc&&globalThis.gc();let c=t.slice(G*m,G*m*2);await L(c),globalThis.gc&&globalThis.gc();let u=t.slice(G*m*2,G*m*3);await L(u),globalThis.gc&&globalThis.gc();await binFileUtils.endWriteSection(F),l=await p.batchFromMontgomery(l),c=await p.batchFromMontgomery(c),u=await p.batchFromMontgomery(u),x.S1=await o.G1.multiExpAffine(U,l,i,"multiexp S1"),globalThis.gc&&globalThis.gc();x.S2=await o.G1.multiExpAffine(U,c,i,"multiexp S2"),globalThis.gc&&globalThis.gc();x.S3=await o.G1.multiExpAffine(U,u,i,"multiexp S3"),globalThis.gc&&globalThis.gc();function f(e,a){let i;"undefined"===typeof n[e]?r[e]=a:t.set(n[e],a*m),i=a<G?s:a<2*G?p.mul(s,B):p.mul(s,E),n[e]=i}}(12,"sigma"),globalThis.gc&&globalThis.gc(),await async function(e,a){await binFileUtils.startWriteSection(F,e);const t=Math.max(y,1);for(let n=0;n<t;n++){let e=new ffjavascript.BigBuffer(G*m);e.set(p.one,n*m),await L(e),i&&i.debug(`writing ${a} ${n}/${t}`)}await binFileUtils.endWriteSection(F)}(13,"lagrange polynomials"),globalThis.gc&&globalThis.gc(),await binFileUtils.startWriteSection(F,14);const A=new ffjavascript.BigBuffer((G+6)*f);return await n.readToBuffer(A,0,(G+6)*f,r[2][0].p),await F.write(A),await binFileUtils.endWriteSection(F),globalThis.gc&&globalThis.gc(),await async function(){await binFileUtils.startWriteSection(F,1),await F.writeULE32(2),await binFileUtils.endWriteSection(F),await binFileUtils.startWriteSection(F,2);const e=o.q,a=8*(Math.floor((ffjavascript.Scalar.bitLength(e)-1)/64)+1),t=o.r,i=8*(Math.floor((ffjavascript.Scalar.bitLength(t)-1)/64)+1);let s;await F.writeULE32(a),await binFileUtils.writeBigInt(F,e,a),await F.writeULE32(i),await binFileUtils.writeBigInt(F,t,i),await F.writeULE32(_),await F.writeULE32(y),await F.writeULE32(G),await F.writeULE32(h.length),await F.writeULE32(g.length),await F.write(B),await F.write(E),await F.write(d.toAffine(x.Qm)),await F.write(d.toAffine(x.Ql)),await F.write(d.toAffine(x.Qr)),await F.write(d.toAffine(x.Qo)),await F.write(d.toAffine(x.Qc)),await F.write(d.toAffine(x.S1)),await F.write(d.toAffine(x.S2)),await F.write(d.toAffine(x.S3)),s=await n.read(w,r[3][0].p+w),await F.write(s),await binFileUtils.endWriteSection(F)}(),await F.close(),await l.close(),await n.close(),void(i&&i.info("Setup Finished"));async function k(e,a,t){await binFileUtils.startWriteSection(F,e);for(let n=0;n<g.length;n++)await F.writeULE32(g[n][a]),i&&n%1e6==0&&i.debug(`writing ${t}: ${n}/${g.length}`);await binFileUtils.endWriteSection(F)}async function C(e,a,t){let n=new ffjavascript.BigBuffer(G*m);for(let r=0;r<g.length;r++)n.set(g[r][a],r*m),i&&r%1e6==0&&i.debug(`writing ${t}: ${r}/${g.length}`);await binFileUtils.startWriteSection(F,e),await L(n),await binFileUtils.endWriteSection(F),n=await p.batchFromMontgomery(n),x[t]=await o.G1.multiExpAffine(U,n,i,"multiexp "+t)}async function L(e){const a=await p.ifft(e),t=new ffjavascript.BigBuffer(G*m*4);t.set(a,0);const i=await p.fft(t);await F.write(a),await F.write(i)}}const{stringifyBigInts:stringifyBigInts}=ffjavascript.utils,{keccak256:keccak256$1}=jsSha3__default.default;async function plonk16Prove(e,a,t){const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(a,"wtns",2,1<<25,1<<23),r=await readHeader(i,n),{fd:o,sections:s}=await binFileUtils__namespace.readBinFile(e,"zkey",2,1<<25,1<<23),l=await readHeader$1(o,s);if("plonk"!=l.protocol)throw new Error("zkey file is not plonk");if(!ffjavascript.Scalar.eq(l.r,r.q))throw new Error("Curve of the witness does not match the curve of the proving key");if(r.nWitness!=l.nVars-l.nAdditions)throw new Error(`Invalid witness length. Circuit: ${l.nVars}, witness: ${r.nWitness}, ${l.nAdditions}`);const c=await getCurveFromQ(l.q),u=c.Fr,f=c.G1,d=c.Fr.n8;t&&t.debug("Reading Wtns");const w=await binFileUtils__namespace.readSection(i,n,2);w.set(u.zero,0);const p=new ffjavascript.BigBuffer(d*l.nAdditions);let m,b,g,h,_,y,F,v,G,U,S,B,E,x;await async function(){const e=await binFileUtils__namespace.readSection(o,s,3),a=8+2*c.Fr.n8;for(let t=0;t<l.nAdditions;t++){const i=$(e,t*a),n=$(e,t*a+4),r=e.slice(t*a+8,t*a+8+d),o=e.slice(t*a+8+d,t*a+8+2*d),s=j(i),l=j(n),u=c.Fr.add(c.Fr.mul(r,s),c.Fr.mul(o,l));p.set(u,d*t)}}();let A={};const k=new ffjavascript.BigBuffer(l.domainSize*d*4*3);let C=s[12][0].p+l.domainSize*d;await o.readToBuffer(k,0,l.domainSize*d*4,C),C+=l.domainSize*d*5,await o.readToBuffer(k,l.domainSize*d*4,l.domainSize*d*4,C),C+=l.domainSize*d*5,await o.readToBuffer(k,l.domainSize*d*8,l.domainSize*d*4,C);const L=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(L,0,l.domainSize*d,s[12][0].p);const R=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(R,0,l.domainSize*d,s[12][0].p+5*l.domainSize*d);const z=await binFileUtils__namespace.readSection(o,s,14),T={};await async function(){T.b=[];for(let e=1;e<=9;e++)T.b[e]=c.Fr.random();[m,b,g]=await async function(){let e=new ffjavascript.BigBuffer(l.domainSize*d),a=new ffjavascript.BigBuffer(l.domainSize*d),t=new ffjavascript.BigBuffer(l.domainSize*d);const i=await binFileUtils__namespace.readSection(o,s,4),n=await binFileUtils__namespace.readSection(o,s,5),r=await binFileUtils__namespace.readSection(o,s,6);for(let o=0;o<l.nConstrains;o++){const s=$(i,4*o);e.set(j(s),o*d);const l=$(n,4*o);a.set(j(l),o*d);const c=$(r,4*o);t.set(j(c),o*d)}return e=await u.batchToMontgomery(e),a=await u.batchToMontgomery(a),t=await u.batchToMontgomery(t),[e,a,t]}(),[G,_]=await M(m,[T.b[2],T.b[1]]),[U,y]=await M(b,[T.b[4],T.b[3]]),[S,F]=await M(g,[T.b[6],T.b[5]]),A.A=await q(G,"multiexp A"),A.B=await q(U,"multiexp B"),A.C=await q(S,"multiexp C")}(),await async function(){const e=new Uint8Array(l.nPublic*d+2*f.F.n8*3);for(let t=0;t<l.nPublic;t++)u.toRprBE(e,t*d,m.slice(t*d,(t+1)*d));f.toRprUncompressed(e,l.nPublic*d+0,A.A),f.toRprUncompressed(e,l.nPublic*d+2*f.F.n8,A.B),f.toRprUncompressed(e,l.nPublic*d+4*f.F.n8,A.C),T.beta=I(e),t&&t.debug("beta: "+u.toString(T.beta));const a=new Uint8Array(d);u.toRprBE(a,0,T.beta),T.gamma=I(a),t&&t.debug("gamma: "+u.toString(T.gamma));let i=new ffjavascript.BigBuffer(u.n8*l.domainSize),n=new ffjavascript.BigBuffer(u.n8*l.domainSize);i.set(u.one,0),n.set(u.one,0);let r=u.one;for(let t=0;t<l.domainSize;t++){let e=m.slice(t*d,(t+1)*d);e=u.add(e,u.mul(T.beta,r)),e=u.add(e,T.gamma);let a=b.slice(t*d,(t+1)*d);a=u.add(a,u.mul(l.k1,u.mul(T.beta,r))),a=u.add(a,T.gamma);let o=g.slice(t*d,(t+1)*d);o=u.add(o,u.mul(l.k2,u.mul(T.beta,r))),o=u.add(o,T.gamma);const s=u.mul(e,u.mul(a,o));let c=m.slice(t*d,(t+1)*d);c=u.add(c,u.mul(k.slice(t*d*4,t*d*4+d),T.beta)),c=u.add(c,T.gamma);let f=b.slice(t*d,(t+1)*d);f=u.add(f,u.mul(k.slice(4*(l.domainSize+t)*d,4*(l.domainSize+t)*d+d),T.beta)),f=u.add(f,T.gamma);let w=g.slice(t*d,(t+1)*d);w=u.add(w,u.mul(k.slice(4*(2*l.domainSize+t)*d,4*(2*l.domainSize+t)*d+d),T.beta)),w=u.add(w,T.gamma);const p=u.mul(c,u.mul(f,w));i.set(u.mul(i.slice(t*d,(t+1)*d),s),(t+1)%l.domainSize*d),n.set(u.mul(n.slice(t*d,(t+1)*d),p),(t+1)%l.domainSize*d),r=u.mul(r,u.w[l.power])}n=await u.batchInverse(n);for(let t=0;t<l.domainSize;t++)i.set(u.mul(i.slice(t*d,(t+1)*d),n.slice(t*d,(t+1)*d)),t*d);if(!u.eq(i.slice(0,d),u.one))throw new Error("Copy constraints does not match");h=i,[B,v]=await M(h,[T.b[9],T.b[8],T.b[7]]),A.Z=await q(B,"multiexp Z")}(),await async function(){t&&t.debug("phse3: Reading QM4");const e=new ffjavascript.BigBuffer(4*l.domainSize*d);await o.readToBuffer(e,0,l.domainSize*d*4,s[7][0].p+l.domainSize*d),t&&t.debug("phse3: Reading QL4");const a=new ffjavascript.BigBuffer(4*l.domainSize*d);await o.readToBuffer(a,0,l.domainSize*d*4,s[8][0].p+l.domainSize*d),t&&t.debug("phse3: Reading QR4");const i=new ffjavascript.BigBuffer(4*l.domainSize*d);await o.readToBuffer(i,0,l.domainSize*d*4,s[9][0].p+l.domainSize*d),t&&t.debug("phse3: Reading QO4");const n=new ffjavascript.BigBuffer(4*l.domainSize*d);await o.readToBuffer(n,0,l.domainSize*d*4,s[10][0].p+l.domainSize*d),t&&t.debug("phse3: Reading QC4");const r=new ffjavascript.BigBuffer(4*l.domainSize*d);await o.readToBuffer(r,0,l.domainSize*d*4,s[11][0].p+l.domainSize*d);const c=await binFileUtils__namespace.readSection(o,s,13),w=new Uint8Array(2*f.F.n8);f.toRprUncompressed(w,0,A.Z),T.alpha=I(w),t&&t.debug("alpha: "+u.toString(T.alpha));const p=[u.zero,u.add(u.e(-1),u.w[2]),u.e(-2),u.sub(u.e(-1),u.w[2])],b=[u.zero,u.add(u.zero,u.mul(u.e(-2),u.w[2])),u.e(4),u.sub(u.zero,u.mul(u.e(-2),u.w[2]))],g=[u.zero,u.add(u.e(2),u.mul(u.e(2),u.w[2])),u.e(-8),u.sub(u.e(2),u.mul(u.e(2),u.w[2]))],h=new ffjavascript.BigBuffer(4*l.domainSize*d),G=new ffjavascript.BigBuffer(4*l.domainSize*d);let U=u.one;for(let o=0;o<4*l.domainSize;o++){o%4096==0&&t&&t.debug(`calculating t ${o}/${4*l.domainSize}`);const s=_.slice(o*d,o*d+d),f=y.slice(o*d,o*d+d),w=F.slice(o*d,o*d+d),p=v.slice(o*d,o*d+d),b=v.slice((o+4*l.domainSize+4)%(4*l.domainSize)*d,(o+4*l.domainSize+4)%(4*l.domainSize)*d+d),g=e.slice(o*d,o*d+d),S=a.slice(o*d,o*d+d),B=i.slice(o*d,o*d+d),E=n.slice(o*d,o*d+d),A=r.slice(o*d,o*d+d),L=k.slice(o*d,o*d+d),R=k.slice((o+4*l.domainSize)*d,(o+4*l.domainSize)*d+d),z=k.slice((o+8*l.domainSize)*d,(o+8*l.domainSize)*d+d),P=u.add(T.b[2],u.mul(T.b[1],U)),$=u.add(T.b[4],u.mul(T.b[3],U)),j=u.add(T.b[6],u.mul(T.b[5],U)),I=u.square(U),H=u.add(u.add(u.mul(T.b[7],I),u.mul(T.b[8],U)),T.b[9]),O=u.mul(U,u.w[l.power]),q=u.square(O),M=u.add(u.add(u.mul(T.b[7],q),u.mul(T.b[8],O)),T.b[9]);let K=u.zero;for(let e=0;e<l.nPublic;e++)K=u.sub(K,u.mul(c.slice((5*e*l.domainSize+l.domainSize+o)*d,(5*e*l.domainSize+l.domainSize+o+1)*d),m.slice(e*d,(e+1)*d)));let[V,W]=x(s,f,P,$,o%4);V=u.mul(V,g),W=u.mul(W,g),V=u.add(V,u.mul(s,S)),W=u.add(W,u.mul(P,S)),V=u.add(V,u.mul(f,B)),W=u.add(W,u.mul($,B)),V=u.add(V,u.mul(w,E)),W=u.add(W,u.mul(j,E)),V=u.add(V,K),V=u.add(V,A);const N=u.mul(T.beta,U);let D=s;D=u.add(D,N),D=u.add(D,T.gamma);let Q=f;Q=u.add(Q,u.mul(N,l.k1)),Q=u.add(Q,T.gamma);let Z=w;Z=u.add(Z,u.mul(N,l.k2)),Z=u.add(Z,T.gamma);let J=p,[X,Y]=C(D,Q,Z,J,P,$,j,H,o%4);X=u.mul(X,T.alpha),Y=u.mul(Y,T.alpha);let ee=s;ee=u.add(ee,u.mul(T.beta,L)),ee=u.add(ee,T.gamma);let ae=f;ae=u.add(ae,u.mul(T.beta,R)),ae=u.add(ae,T.gamma);let te=w;te=u.add(te,u.mul(T.beta,z)),te=u.add(te,T.gamma);let ie=b,[ne,re]=C(ee,ae,te,ie,P,$,j,M,o%4);ne=u.mul(ne,T.alpha),re=u.mul(re,T.alpha);let oe=u.sub(p,u.one);oe=u.mul(oe,c.slice((l.domainSize+o)*d,(l.domainSize+o+1)*d)),oe=u.mul(oe,u.mul(T.alpha,T.alpha));let se=u.mul(H,c.slice((l.domainSize+o)*d,(l.domainSize+o+1)*d));se=u.mul(se,u.mul(T.alpha,T.alpha));let le=u.add(u.sub(u.add(V,X),ne),oe),ce=u.add(u.sub(u.add(W,Y),re),se);h.set(le,o*d),G.set(ce,o*d),U=u.mul(U,u.w[l.power+2])}t&&t.debug("ifft T");let S=await u.ifft(h);t&&t.debug("dividing T/Z");for(let t=0;t<l.domainSize;t++)S.set(u.neg(S.slice(t*d,t*d+d)),t*d);for(let t=l.domainSize;t<4*l.domainSize;t++){const e=u.sub(S.slice((t-l.domainSize)*d,(t-l.domainSize)*d+d),S.slice(t*d,t*d+d));if(S.set(e,t*d),t>3*l.domainSize-4&&!u.isZero(e))throw new Error("T Polynomial is not divisible")}t&&t.debug("ifft Tz");const B=await u.ifft(G);for(let t=0;t<4*l.domainSize;t++){const e=B.slice(t*d,(t+1)*d);if(t>3*l.domainSize+5){if(!u.isZero(e))throw new Error("Tz Polynomial is not well calculated")}else S.set(u.add(S.slice(t*d,(t+1)*d),e),t*d)}function x(e,a,t,i,n){let r,o;const s=u.mul(e,a),l=u.mul(e,i),c=u.mul(t,a);r=s;let f=u.mul(t,i);return o=u.add(l,c),n&&(o=u.add(o,u.mul(p[n],f))),[r,o]}function C(e,a,t,i,n,r,o,s,l){let c,f;const d=u.mul(e,a),w=u.mul(e,r),m=u.mul(n,a),h=u.mul(n,r),_=u.mul(t,i),y=u.mul(t,s),F=u.mul(o,i),v=u.mul(o,s);c=u.mul(d,_);let G=u.mul(m,_);G=u.add(G,u.mul(w,_)),G=u.add(G,u.mul(d,F)),G=u.add(G,u.mul(d,y));let U=u.mul(h,_);U=u.add(U,u.mul(m,F)),U=u.add(U,u.mul(m,y)),U=u.add(U,u.mul(w,F)),U=u.add(U,u.mul(w,y)),U=u.add(U,u.mul(d,v));let S=u.mul(w,v);S=u.add(S,u.mul(m,v)),S=u.add(S,u.mul(h,y)),S=u.add(S,u.mul(h,F));let B=u.mul(h,v);return f=G,l&&(f=u.add(f,u.mul(p[l],U)),f=u.add(f,u.mul(b[l],S)),f=u.add(f,u.mul(g[l],B))),[c,f]}E=S.slice(0,(3*l.domainSize+6)*d),A.T1=await q(S.slice(0,l.domainSize*d),"multiexp T1"),A.T2=await q(S.slice(l.domainSize*d,2*l.domainSize*d),"multiexp T2"),A.T3=await q(S.slice(2*l.domainSize*d,(3*l.domainSize+6)*d),"multiexp T3")}(),await async function(){const e=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(e,0,l.domainSize*d,s[7][0].p);const a=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(a,0,l.domainSize*d,s[8][0].p);const i=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(i,0,l.domainSize*d,s[9][0].p);const n=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(n,0,l.domainSize*d,s[10][0].p);const r=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(r,0,l.domainSize*d,s[11][0].p);const c=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(c,0,l.domainSize*d,s[12][0].p+10*l.domainSize*d);const w=new Uint8Array(2*f.F.n8*3);f.toRprUncompressed(w,0,A.T1),f.toRprUncompressed(w,2*f.F.n8,A.T2),f.toRprUncompressed(w,4*f.F.n8,A.T3),T.xi=I(w),t&&t.debug("xi: "+u.toString(T.xi));A.eval_a=H(G,T.xi),A.eval_b=H(U,T.xi),A.eval_c=H(S,T.xi),A.eval_s1=H(L,T.xi),A.eval_s2=H(R,T.xi),A.eval_t=H(E,T.xi),A.eval_zw=H(B,u.mul(T.xi,u.w[l.power]));const p=u.mul(A.eval_a,A.eval_b);let m=A.eval_a;const b=u.mul(T.beta,T.xi);m=u.add(m,b),m=u.add(m,T.gamma);let g=A.eval_b;g=u.add(g,u.mul(b,l.k1)),g=u.add(g,T.gamma);let h=A.eval_c;h=u.add(h,u.mul(b,l.k2)),h=u.add(h,T.gamma);const _=u.mul(u.mul(u.mul(m,g),h),T.alpha);let y=A.eval_a;y=u.add(y,u.mul(T.beta,A.eval_s1)),y=u.add(y,T.gamma);let F=A.eval_b;F=u.add(F,u.mul(T.beta,A.eval_s2)),F=u.add(F,T.gamma);let v=u.mul(y,F);v=u.mul(v,T.beta),v=u.mul(v,A.eval_zw),v=u.mul(v,T.alpha),T.xim=T.xi;for(let t=0;t<l.power;t++)T.xim=u.mul(T.xim,T.xim);const k=u.div(u.sub(T.xim,u.one),u.mul(u.sub(T.xi,u.one),u.e(l.domainSize))),C=u.mul(k,u.mul(T.alpha,T.alpha)),z=v,P=u.add(_,C);x=new ffjavascript.BigBuffer((l.domainSize+3)*d);for(let t=0;t<l.domainSize+3;t++){let o=u.mul(P,B.slice(t*d,(t+1)*d));t<l.domainSize&&(o=u.add(o,u.mul(p,e.slice(t*d,(t+1)*d))),o=u.add(o,u.mul(A.eval_a,a.slice(t*d,(t+1)*d))),o=u.add(o,u.mul(A.eval_b,i.slice(t*d,(t+1)*d))),o=u.add(o,u.mul(A.eval_c,n.slice(t*d,(t+1)*d))),o=u.add(o,r.slice(t*d,(t+1)*d)),o=u.sub(o,u.mul(z,c.slice(t*d,(t+1)*d)))),x.set(o,t*d)}A.eval_r=H(x,T.xi)}(),await async function(){const e=new Uint8Array(7*d);u.toRprBE(e,0,A.eval_a),u.toRprBE(e,d,A.eval_b),u.toRprBE(e,2*d,A.eval_c),u.toRprBE(e,3*d,A.eval_s1),u.toRprBE(e,4*d,A.eval_s2),u.toRprBE(e,5*d,A.eval_zw),u.toRprBE(e,6*d,A.eval_r),T.v=[],T.v[1]=I(e),t&&t.debug("v: "+u.toString(T.v[1]));for(let t=2;t<=6;t++)T.v[t]=u.mul(T.v[t-1],T.v[1]);let a=new ffjavascript.BigBuffer((l.domainSize+6)*d);const i=u.mul(T.xim,T.xim);for(let t=0;t<l.domainSize+6;t++){let e=u.zero;e=u.add(e,u.mul(i,E.slice((2*l.domainSize+t)*d,(2*l.domainSize+t+1)*d))),t<l.domainSize+3&&(e=u.add(e,u.mul(T.v[1],x.slice(t*d,(t+1)*d)))),t<l.domainSize+2&&(e=u.add(e,u.mul(T.v[2],G.slice(t*d,(t+1)*d))),e=u.add(e,u.mul(T.v[3],U.slice(t*d,(t+1)*d))),e=u.add(e,u.mul(T.v[4],S.slice(t*d,(t+1)*d)))),t<l.domainSize&&(e=u.add(e,E.slice(t*d,(t+1)*d)),e=u.add(e,u.mul(T.xim,E.slice((l.domainSize+t)*d,(l.domainSize+t+1)*d))),e=u.add(e,u.mul(T.v[5],L.slice(t*d,(t+1)*d))),e=u.add(e,u.mul(T.v[6],R.slice(t*d,(t+1)*d)))),a.set(e,t*d)}let n=a.slice(0,d);n=u.sub(n,A.eval_t),n=u.sub(n,u.mul(T.v[1],A.eval_r)),n=u.sub(n,u.mul(T.v[2],A.eval_a)),n=u.sub(n,u.mul(T.v[3],A.eval_b)),n=u.sub(n,u.mul(T.v[4],A.eval_c)),n=u.sub(n,u.mul(T.v[5],A.eval_s1)),n=u.sub(n,u.mul(T.v[6],A.eval_s2)),a.set(n,0),a=O(a,T.xi),A.Wxi=await q(a,"multiexp Wxi");let r=new ffjavascript.BigBuffer((l.domainSize+3)*d);for(let t=0;t<l.domainSize+3;t++){const e=B.slice(t*d,(t+1)*d);r.set(e,t*d)}n=r.slice(0,d),n=u.sub(n,A.eval_zw),r.set(n,0),r=O(r,u.mul(T.xi,u.w[l.power])),A.Wxiw=await q(r,"multiexp Wxiw")}(),A.protocol="plonk",A.curve=c.name,await o.close(),await i.close();let P=[];for(let K=1;K<=l.nPublic;K++){const e=w.slice(K*u.n8,K*u.n8+u.n8);P.push(ffjavascript.Scalar.fromRprLE(e))}return A.A=f.toObject(A.A),A.B=f.toObject(A.B),A.C=f.toObject(A.C),A.Z=f.toObject(A.Z),A.T1=f.toObject(A.T1),A.T2=f.toObject(A.T2),A.T3=f.toObject(A.T3),A.eval_a=u.toObject(A.eval_a),A.eval_b=u.toObject(A.eval_b),A.eval_c=u.toObject(A.eval_c),A.eval_s1=u.toObject(A.eval_s1),A.eval_s2=u.toObject(A.eval_s2),A.eval_zw=u.toObject(A.eval_zw),A.eval_t=u.toObject(A.eval_t),A.eval_r=u.toObject(A.eval_r),A.Wxi=f.toObject(A.Wxi),A.Wxiw=f.toObject(A.Wxiw),delete A.eval_t,A=stringifyBigInts(A),P=stringifyBigInts(P),{proof:A,publicSignals:P};function $(e,a){const t=e.slice(a,a+4);return new DataView(t.buffer,t.byteOffset,t.byteLength).getUint32(0,!0)}function j(e){return e<l.nVars-l.nAdditions?w.slice(e*d,e*d+d):e<l.nVars?p.slice((e-(l.nVars-l.nAdditions))*d,(e-(l.nVars-l.nAdditions))*d+d):c.Fr.zero}function I(e){const a=ffjavascript.Scalar.fromRprBE(new Uint8Array(keccak256$1.arrayBuffer(e)));return u.e(a)}function H(e,a){const t=e.byteLength/d;if(0==t)return u.zero;let i=e.slice((t-1)*d,t*d);for(let n=t-2;n>=0;n--)i=u.add(u.mul(i,a),e.slice(n*d,(n+1)*d));return i}function O(e,a){const t=e.byteLength/d,i=new ffjavascript.BigBuffer(t*d);i.set(u.zero,(t-1)*d),i.set(e.slice((t-1)*d,t*d),(t-2)*d);for(let n=t-3;n>=0;n--)i.set(u.add(e.slice((n+1)*d,(n+2)*d),u.mul(a,i.slice((n+1)*d,(n+2)*d))),n*d);if(!u.eq(e.slice(0,d),u.mul(u.neg(a),i.slice(0,d))))throw new Error("Polinomial does not divide");return i}async function q(e,a){const i=e.byteLength/d,n=z.slice(0,i*c.G1.F.n8*2),r=await c.Fr.batchFromMontgomery(e);let o=await c.G1.multiExpAffine(n,r,t,a);return o=c.G1.toAffine(o),o}async function M(e,a){a=a||[];let t=await u.ifft(e);const i=new ffjavascript.BigBuffer(d*l.domainSize*4);i.set(t,0);const n=new ffjavascript.BigBuffer(d*(l.domainSize+a.length));n.set(t,0);for(let r=0;r<a.length;r++)n.set(u.add(n.slice((l.domainSize+r)*d,(l.domainSize+r+1)*d),a[r]),(l.domainSize+r)*d),n.set(u.sub(n.slice(r*d,(r+1)*d),a[r]),r*d);return[n,await u.fft(i)]}}async function plonkFullProve(e,a,t,i){const n={type:"mem"};return await wtnsCalculate(e,a,n),await plonk16Prove(t,n,i)}const{unstringifyBigInts:unstringifyBigInts}=ffjavascript.utils,{keccak256:keccak256}=jsSha3__default.default;async function plonkVerify(e,a,t,i){e=unstringifyBigInts(e),t=unstringifyBigInts(t),a=unstringifyBigInts(a);const n=await getCurveFromName(e.curve),r=n.Fr,o=n.G1;if(t=fromObjectProof(n,t),e=fromObjectVk(n,e),!isWellConstructed(n,t))return i.error("Proof is not well constructed"),!1;if(a.length!=e.nPublic)return i.error("Invalid number of public inputs"),!1;const s=calculateChallanges(n,t,a);i&&(i.debug("beta: "+r.toString(s.beta,16)),i.debug("gamma: "+r.toString(s.gamma,16)),i.debug("alpha: "+r.toString(s.alpha,16)),i.debug("xi: "+r.toString(s.xi,16)),i.debug("v1: "+r.toString(s.v[1],16)),i.debug("v6: "+r.toString(s.v[6],16)),i.debug("u: "+r.toString(s.u,16)));const l=calculateLagrangeEvaluations(n,s,e);if(i){i.debug("Lagrange Evaluations: ");for(let e=1;e<l.length;e++)i.debug(`L${e}(xi)=`+r.toString(l[e],16))}if(a.length!=e.nPublic)return i.error("Number of public signals does not match with vk"),!1;const c=calculatePl(n,a,l);i&&i.debug("Pl: "+r.toString(c,16));const u=calculateT(n,t,s,c,l[1]);i&&i.debug("t: "+r.toString(u,16));const f=calculateD(n,t,s,e,l[1]);i&&i.debug("D: "+o.toString(o.toAffine(f),16));const d=calculateF(n,t,s,e,f);i&&i.debug("F: "+o.toString(o.toAffine(d),16));const w=calculateE(n,t,s,e,u);i&&i.debug("E: "+o.toString(o.toAffine(w),16));const p=await isValidPairing(n,t,s,e,w,d);return i&&(p?i.info("OK!"):i.warn("Invalid Proof")),p}function fromObjectProof(e,a){const t=e.G1,i=e.Fr,n={};return n.A=t.fromObject(a.A),n.B=t.fromObject(a.B),n.C=t.fromObject(a.C),n.Z=t.fromObject(a.Z),n.T1=t.fromObject(a.T1),n.T2=t.fromObject(a.T2),n.T3=t.fromObject(a.T3),n.eval_a=i.fromObject(a.eval_a),n.eval_b=i.fromObject(a.eval_b),n.eval_c=i.fromObject(a.eval_c),n.eval_zw=i.fromObject(a.eval_zw),n.eval_s1=i.fromObject(a.eval_s1),n.eval_s2=i.fromObject(a.eval_s2),n.eval_r=i.fromObject(a.eval_r),n.Wxi=t.fromObject(a.Wxi),n.Wxiw=t.fromObject(a.Wxiw),n}function fromObjectVk(e,a){const t=e.G1,i=e.G2,n=e.Fr,r=a;return r.Qm=t.fromObject(a.Qm),r.Ql=t.fromObject(a.Ql),r.Qr=t.fromObject(a.Qr),r.Qo=t.fromObject(a.Qo),r.Qc=t.fromObject(a.Qc),r.S1=t.fromObject(a.S1),r.S2=t.fromObject(a.S2),r.S3=t.fromObject(a.S3),r.k1=n.fromObject(a.k1),r.k2=n.fromObject(a.k2),r.X_2=i.fromObject(a.X_2),r}function isWellConstructed(e,a){const t=e.G1;return!!t.isValid(a.A)&&(!!t.isValid(a.B)&&(!!t.isValid(a.C)&&(!!t.isValid(a.Z)&&(!!t.isValid(a.T1)&&(!!t.isValid(a.T2)&&(!!t.isValid(a.T3)&&(!!t.isValid(a.Wxi)&&!!t.isValid(a.Wxiw))))))))}function calculateChallanges(e,a,t){const i=e.G1,n=e.Fr,r=e.Fr.n8,o={},s=new Uint8Array(t.length*r+2*i.F.n8*3);for(let w=0;w<t.length;w++)n.toRprBE(s,w*r,n.e(t[w]));i.toRprUncompressed(s,t.length*r+0,a.A),i.toRprUncompressed(s,t.length*r+2*i.F.n8,a.B),i.toRprUncompressed(s,t.length*r+4*i.F.n8,a.C),o.beta=hashToFr(e,s);const l=new Uint8Array(r);n.toRprBE(l,0,o.beta),o.gamma=hashToFr(e,l);const c=new Uint8Array(2*i.F.n8);i.toRprUncompressed(c,0,a.Z),o.alpha=hashToFr(e,c);const u=new Uint8Array(2*i.F.n8*3);i.toRprUncompressed(u,0,a.T1),i.toRprUncompressed(u,2*i.F.n8,a.T2),i.toRprUncompressed(u,4*i.F.n8,a.T3),o.xi=hashToFr(e,u);const f=new Uint8Array(7*r);n.toRprBE(f,0,a.eval_a),n.toRprBE(f,r,a.eval_b),n.toRprBE(f,2*r,a.eval_c),n.toRprBE(f,3*r,a.eval_s1),n.toRprBE(f,4*r,a.eval_s2),n.toRprBE(f,5*r,a.eval_zw),n.toRprBE(f,6*r,a.eval_r),o.v=[],o.v[1]=hashToFr(e,f);for(let w=2;w<=6;w++)o.v[w]=n.mul(o.v[w-1],o.v[1]);const d=new Uint8Array(2*i.F.n8*2);return i.toRprUncompressed(d,0,a.Wxi),i.toRprUncompressed(d,2*i.F.n8,a.Wxiw),o.u=hashToFr(e,d),o}function calculateLagrangeEvaluations(e,a,t){const i=e.Fr;let n=a.xi,r=1;for(let c=0;c<t.power;c++)n=i.square(n),r*=2;a.xin=n,a.zh=i.sub(n,i.one);const o=[],s=i.e(r);let l=i.one;for(let c=1;c<=Math.max(1,t.nPublic);c++)o[c]=i.div(i.mul(l,a.zh),i.mul(s,i.sub(a.xi,l))),l=i.mul(l,i.w[t.power]);return o}function hashToFr(e,a){const t=ffjavascript.Scalar.fromRprBE(new Uint8Array(keccak256.arrayBuffer(a)));return e.Fr.e(t)}function calculatePl(e,a,t){const i=e.Fr;let n=i.zero;for(let r=0;r<a.length;r++){const e=i.e(a[r]);n=i.sub(n,i.mul(e,t[r+1]))}return n}function calculateT(e,a,t,i,n){const r=e.Fr;let o=a.eval_r;o=r.add(o,i);let s=a.eval_a;s=r.add(s,r.mul(t.beta,a.eval_s1)),s=r.add(s,t.gamma);let l=a.eval_b;l=r.add(l,r.mul(t.beta,a.eval_s2)),l=r.add(l,t.gamma);let c=a.eval_c;c=r.add(c,t.gamma);let u=r.mul(r.mul(s,l),c);u=r.mul(u,a.eval_zw),u=r.mul(u,t.alpha),o=r.sub(o,u),o=r.sub(o,r.mul(n,r.square(t.alpha)));return r.div(o,t.zh)}function calculateD(e,a,t,i,n){const r=e.G1,o=e.Fr;let s=o.mul(o.mul(a.eval_a,a.eval_b),t.v[1]),l=r.timesFr(i.Qm,s),c=o.mul(a.eval_a,t.v[1]);l=r.add(l,r.timesFr(i.Ql,c));let u=o.mul(a.eval_b,t.v[1]);l=r.add(l,r.timesFr(i.Qr,u));let f=o.mul(a.eval_c,t.v[1]);l=r.add(l,r.timesFr(i.Qo,f)),l=r.add(l,r.timesFr(i.Qc,t.v[1]));const d=o.mul(t.beta,t.xi);let w=a.eval_a;w=o.add(w,d),w=o.add(w,t.gamma);let p=a.eval_b;p=o.add(p,o.mul(d,i.k1)),p=o.add(p,t.gamma);let m=a.eval_c;m=o.add(m,o.mul(d,i.k2)),m=o.add(m,t.gamma);let b=o.mul(o.mul(w,p),m);b=o.mul(b,o.mul(t.alpha,t.v[1]));let g=o.mul(o.mul(n,o.square(t.alpha)),t.v[1]);b=o.add(b,g),b=o.add(b,t.u),l=r.add(l,r.timesFr(a.Z,b));let h=a.eval_a;h=o.add(h,o.mul(t.beta,a.eval_s1)),h=o.add(h,t.gamma);let _=a.eval_b;_=o.add(_,o.mul(t.beta,a.eval_s2)),_=o.add(_,t.gamma);let y=o.mul(h,_);return y=o.mul(y,t.alpha),y=o.mul(y,t.v[1]),y=o.mul(y,t.beta),y=o.mul(y,a.eval_zw),l=r.sub(l,r.timesFr(i.S3,y)),l}function calculateF(e,a,t,i,n){const r=e.G1,o=e.Fr;let s=a.T1;return s=r.add(s,r.timesFr(a.T2,t.xin)),s=r.add(s,r.timesFr(a.T3,o.square(t.xin))),s=r.add(s,n),s=r.add(s,r.timesFr(a.A,t.v[2])),s=r.add(s,r.timesFr(a.B,t.v[3])),s=r.add(s,r.timesFr(a.C,t.v[4])),s=r.add(s,r.timesFr(i.S1,t.v[5])),s=r.add(s,r.timesFr(i.S2,t.v[6])),s}function calculateE(e,a,t,i,n){const r=e.G1,o=e.Fr;let s=n;s=o.add(s,o.mul(t.v[1],a.eval_r)),s=o.add(s,o.mul(t.v[2],a.eval_a)),s=o.add(s,o.mul(t.v[3],a.eval_b)),s=o.add(s,o.mul(t.v[4],a.eval_c)),s=o.add(s,o.mul(t.v[5],a.eval_s1)),s=o.add(s,o.mul(t.v[6],a.eval_s2)),s=o.add(s,o.mul(t.u,a.eval_zw));return r.timesFr(r.one,s)}async function isValidPairing(e,a,t,i,n,r){const o=e.G1,s=e.Fr;let l=a.Wxi;l=o.add(l,o.timesFr(a.Wxiw,t.u));let c=o.timesFr(a.Wxi,t.xi);const u=s.mul(s.mul(t.u,t.xi),s.w[i.power]);c=o.add(c,o.timesFr(a.Wxiw,u)),c=o.add(c,r),c=o.sub(c,n);return await e.pairingEq(o.neg(l),i.X_2,c,e.G2.one)}function i2hex(e){return("0"+e.toString(16)).slice(-2)}function p256(e){let a=e.toString(16);for(;a.length<64;)a="0"+a;return a=`"0x${a}"`,a}async function plonkExportSolidityCallData(e,a){const t=await getCurveFromName(e.curve),i=t.G1,n=t.Fr;let r="";for(let s=0;s<a.length;s++)""!=r&&(r+=","),r+=p256(a[s]);const o=new Uint8Array(2*i.F.n8*9+7*n.n8);i.toRprUncompressed(o,0,i.e(e.A)),i.toRprUncompressed(o,2*i.F.n8,i.e(e.B)),i.toRprUncompressed(o,4*i.F.n8,i.e(e.C)),i.toRprUncompressed(o,6*i.F.n8,i.e(e.Z)),i.toRprUncompressed(o,8*i.F.n8,i.e(e.T1)),i.toRprUncompressed(o,10*i.F.n8,i.e(e.T2)),i.toRprUncompressed(o,12*i.F.n8,i.e(e.T3)),i.toRprUncompressed(o,14*i.F.n8,i.e(e.Wxi)),i.toRprUncompressed(o,16*i.F.n8,i.e(e.Wxiw)),n.toRprBE(o,18*i.F.n8,n.e(e.eval_a)),n.toRprBE(o,18*i.F.n8+n.n8,n.e(e.eval_b)),n.toRprBE(o,18*i.F.n8+2*n.n8,n.e(e.eval_c)),n.toRprBE(o,18*i.F.n8+3*n.n8,n.e(e.eval_s1)),n.toRprBE(o,18*i.F.n8+4*n.n8,n.e(e.eval_s2)),n.toRprBE(o,18*i.F.n8+5*n.n8,n.e(e.eval_zw)),n.toRprBE(o,18*i.F.n8+6*n.n8,n.e(e.eval_r));return"0x"+Array.from(o).map(i2hex).join("")+",["+r+"]"}var plonk=Object.freeze({__proto__:null,setup:plonkSetup,fullProve:plonkFullProve,prove:plonk16Prove,verify:plonkVerify,exportSolidityCallData:plonkExportSolidityCallData});exports.groth16=groth16,exports.plonk=plonk,exports.powersOfTau=powersoftau,exports.r1cs=r1cs,exports.wtns=wtns,exports.zKey=zkey;